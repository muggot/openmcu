//
// h4503.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h4503.h"
#endif

#include <ptlib.h>
#include "h450/h4503.h"

#define new PNEW


#if ! H323_DISABLE_H4503



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_H323CallDiversionOperations[]={
        {"activateDiversionQ",15}
       ,{"deactivateDiversionQ",16}
       ,{"interrogateDiversionQ",17}
       ,{"checkRestriction",18}
       ,{"callRerouting",19}
       ,{"divertingLegInformation1",20}
       ,{"divertingLegInformation2",21}
       ,{"divertingLegInformation3",22}
       ,{"divertingLegInformation4",100}
       ,{"cfnrDivertedLegFailed",23}
};
#endif
//
// H323CallDiversionOperations
//

H4503_H323CallDiversionOperations::H4503_H323CallDiversionOperations(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 100, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_H323CallDiversionOperations,10
#endif
    )
{
}


H4503_H323CallDiversionOperations & H4503_H323CallDiversionOperations::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_H323CallDiversionOperations::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_H323CallDiversionOperations::Class()), PInvalidCast);
#endif
  return new H4503_H323CallDiversionOperations(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_DiversionReason[]={
        {"unknown",0}
       ,{"cfu",1}
       ,{"cfb",2}
       ,{"cfnr",3}
};
#endif
//
// DiversionReason
//

H4503_DiversionReason::H4503_DiversionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_DiversionReason,4
#endif
    )
{
}


H4503_DiversionReason & H4503_DiversionReason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_DiversionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_DiversionReason::Class()), PInvalidCast);
#endif
  return new H4503_DiversionReason(*this);
}


//
// IntResultList
//

H4503_IntResultList::H4503_IntResultList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 29);
}


PASN_Object * H4503_IntResultList::CreateObject() const
{
  return new H4503_IntResult;
}


H4503_IntResult & H4503_IntResultList::operator[](PINDEX i) const
{
  return (H4503_IntResult &)array[i];
}


PObject * H4503_IntResultList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_IntResultList::Class()), PInvalidCast);
#endif
  return new H4503_IntResultList(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_Procedure[]={
        {"cfu",0}
       ,{"cfb",1}
       ,{"cfnr",2}
};
#endif
//
// Procedure
//

H4503_Procedure::H4503_Procedure(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_Procedure,3
#endif
    )
{
}


H4503_Procedure & H4503_Procedure::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_Procedure::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_Procedure::Class()), PInvalidCast);
#endif
  return new H4503_Procedure(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_SubscriptionOption[]={
        {"noNotification",0}
       ,{"notificationWithoutDivertedToNr",1}
       ,{"notificationWithDivertedToNr",2}
};
#endif
//
// SubscriptionOption
//

H4503_SubscriptionOption::H4503_SubscriptionOption(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_SubscriptionOption,3
#endif
    )
{
}


H4503_SubscriptionOption & H4503_SubscriptionOption::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_SubscriptionOption::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_SubscriptionOption::Class()), PInvalidCast);
#endif
  return new H4503_SubscriptionOption(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_CallDiversionErrors[]={
        {"invalidDivertedNumber",12}
       ,{"specialServiceNumber",14}
       ,{"diversionToServedUserNumber",15}
       ,{"numberOfDiversionsExceeded",24}
       ,{"temporarilyUnavailable",1000}
       ,{"notAuthorized",1007}
       ,{"unspecified",1008}
};
#endif
//
// CallDiversionErrors
//

H4503_CallDiversionErrors::H4503_CallDiversionErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1008, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_CallDiversionErrors,7
#endif
    )
{
}


H4503_CallDiversionErrors & H4503_CallDiversionErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_CallDiversionErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_CallDiversionErrors::Class()), PInvalidCast);
#endif
  return new H4503_CallDiversionErrors(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_BasicService[]={
        {"allServices",0}
};
#endif
//
// BasicService
//

H4503_BasicService::H4503_BasicService(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 0, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_BasicService,1
#endif
    )
{
}


H4503_BasicService & H4503_BasicService::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H4503_BasicService::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_BasicService::Class()), PInvalidCast);
#endif
  return new H4503_BasicService(*this);
}


//
// ExtensionSeq
//

H4503_ExtensionSeq::H4503_ExtensionSeq(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H4503_ExtensionSeq::CreateObject() const
{
  return new H4501_Extension;
}


H4501_Extension & H4503_ExtensionSeq::operator[](PINDEX i) const
{
  return (H4501_Extension &)array[i];
}


PObject * H4503_ExtensionSeq::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_ExtensionSeq::Class()), PInvalidCast);
#endif
  return new H4503_ExtensionSeq(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_IntResult_extension[]={
      {"extensionSeq",0}
     ,{"nonStandardData",1}
};
#endif
//
// IntResult_extension
//

H4503_IntResult_extension::H4503_IntResult_extension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_IntResult_extension,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H4503_IntResult_extension::operator H4503_ExtensionSeq &() const
#else
H4503_IntResult_extension::operator H4503_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H4503_ExtensionSeq), PInvalidCast);
#endif
  return *(H4503_ExtensionSeq *)choice;
}


H4503_IntResult_extension::operator const H4503_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H4503_ExtensionSeq), PInvalidCast);
#endif
  return *(H4503_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H4503_IntResult_extension::operator H225_NonStandardParameter &() const
#else
H4503_IntResult_extension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H4503_IntResult_extension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H4503_IntResult_extension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H4503_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H4503_IntResult_extension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_IntResult_extension::Class()), PInvalidCast);
#endif
  return new H4503_IntResult_extension(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H4503_DivertingLegInfo2Arg_extension[]={
      {"extensionSeq",0}
     ,{"nonStandardData",1}
};
#endif
//
// DivertingLegInfo2Arg_extension
//

H4503_DivertingLegInfo2Arg_extension::H4503_DivertingLegInfo2Arg_extension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H4503_DivertingLegInfo2Arg_extension,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H4503_DivertingLegInfo2Arg_extension::operator H4503_ExtensionSeq &() const
#else
H4503_DivertingLegInfo2Arg_extension::operator H4503_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H4503_ExtensionSeq), PInvalidCast);
#endif
  return *(H4503_ExtensionSeq *)choice;
}


H4503_DivertingLegInfo2Arg_extension::operator const H4503_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H4503_ExtensionSeq), PInvalidCast);
#endif
  return *(H4503_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H4503_DivertingLegInfo2Arg_extension::operator H225_NonStandardParameter &() const
#else
H4503_DivertingLegInfo2Arg_extension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H4503_DivertingLegInfo2Arg_extension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H4503_DivertingLegInfo2Arg_extension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H4503_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H4503_DivertingLegInfo2Arg_extension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_DivertingLegInfo2Arg_extension::Class()), PInvalidCast);
#endif
  return new H4503_DivertingLegInfo2Arg_extension(*this);
}


//
// IntResult
//

H4503_IntResult::H4503_IntResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H4503_IntResult::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "servedUserNr = " << setprecision(indent) << m_servedUserNr << '\n';
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  strm << setw(indent+12) << "procedure = " << setprecision(indent) << m_procedure << '\n';
  strm << setw(indent+20) << "divertedToAddress = " << setprecision(indent) << m_divertedToAddress << '\n';
  strm << setw(indent+16) << "remoteEnabled = " << setprecision(indent) << m_remoteEnabled << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H4503_IntResult::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H4503_IntResult), PInvalidCast);
#endif
  const H4503_IntResult & other = (const H4503_IntResult &)obj;

  Comparison result;

  if ((result = m_servedUserNr.Compare(other.m_servedUserNr)) != EqualTo)
    return result;
  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_procedure.Compare(other.m_procedure)) != EqualTo)
    return result;
  if ((result = m_divertedToAddress.Compare(other.m_divertedToAddress)) != EqualTo)
    return result;
  if ((result = m_remoteEnabled.Compare(other.m_remoteEnabled)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H4503_IntResult::GetDataLength() const
{
  PINDEX length = 0;
  length += m_servedUserNr.GetObjectLength();
  length += m_basicService.GetObjectLength();
  length += m_procedure.GetObjectLength();
  length += m_divertedToAddress.GetObjectLength();
  length += m_remoteEnabled.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H4503_IntResult::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_servedUserNr.Decode(strm))
    return FALSE;
  if (!m_basicService.Decode(strm))
    return FALSE;
  if (!m_procedure.Decode(strm))
    return FALSE;
  if (!m_divertedToAddress.Decode(strm))
    return FALSE;
  if (!m_remoteEnabled.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extension) && !m_extension.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H4503_IntResult::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  m_procedure.Encode(strm);
  m_divertedToAddress.Encode(strm);
  m_remoteEnabled.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H4503_IntResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_IntResult::Class()), PInvalidCast);
#endif
  return new H4503_IntResult(*this);
}


//
// DivertingLegInfo2Arg
//

H4503_DivertingLegInfo2Arg::H4503_DivertingLegInfo2Arg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_diversionCounter.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
  m_redirectingInfo.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
  m_originalCalledInfo.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H4503_DivertingLegInfo2Arg::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "diversionCounter = " << setprecision(indent) << m_diversionCounter << '\n';
  strm << setw(indent+18) << "diversionReason = " << setprecision(indent) << m_diversionReason << '\n';
  if (HasOptionalField(e_originalDiversionReason))
    strm << setw(indent+26) << "originalDiversionReason = " << setprecision(indent) << m_originalDiversionReason << '\n';
  if (HasOptionalField(e_divertingNr))
    strm << setw(indent+14) << "divertingNr = " << setprecision(indent) << m_divertingNr << '\n';
  if (HasOptionalField(e_originalCalledNr))
    strm << setw(indent+19) << "originalCalledNr = " << setprecision(indent) << m_originalCalledNr << '\n';
  if (HasOptionalField(e_redirectingInfo))
    strm << setw(indent+18) << "redirectingInfo = " << setprecision(indent) << m_redirectingInfo << '\n';
  if (HasOptionalField(e_originalCalledInfo))
    strm << setw(indent+21) << "originalCalledInfo = " << setprecision(indent) << m_originalCalledInfo << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H4503_DivertingLegInfo2Arg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H4503_DivertingLegInfo2Arg), PInvalidCast);
#endif
  const H4503_DivertingLegInfo2Arg & other = (const H4503_DivertingLegInfo2Arg &)obj;

  Comparison result;

  if ((result = m_diversionCounter.Compare(other.m_diversionCounter)) != EqualTo)
    return result;
  if ((result = m_diversionReason.Compare(other.m_diversionReason)) != EqualTo)
    return result;
  if ((result = m_originalDiversionReason.Compare(other.m_originalDiversionReason)) != EqualTo)
    return result;
  if ((result = m_divertingNr.Compare(other.m_divertingNr)) != EqualTo)
    return result;
  if ((result = m_originalCalledNr.Compare(other.m_originalCalledNr)) != EqualTo)
    return result;
  if ((result = m_redirectingInfo.Compare(other.m_redirectingInfo)) != EqualTo)
    return result;
  if ((result = m_originalCalledInfo.Compare(other.m_originalCalledInfo)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H4503_DivertingLegInfo2Arg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_diversionCounter.GetObjectLength();
  length += m_diversionReason.GetObjectLength();
  if (HasOptionalField(e_originalDiversionReason))
    length += m_originalDiversionReason.GetObjectLength();
  if (HasOptionalField(e_divertingNr))
    length += m_divertingNr.GetObjectLength();
  if (HasOptionalField(e_originalCalledNr))
    length += m_originalCalledNr.GetObjectLength();
  if (HasOptionalField(e_redirectingInfo))
    length += m_redirectingInfo.GetObjectLength();
  if (HasOptionalField(e_originalCalledInfo))
    length += m_originalCalledInfo.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H4503_DivertingLegInfo2Arg::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_diversionCounter.Decode(strm))
    return FALSE;
  if (!m_diversionReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_originalDiversionReason) && !m_originalDiversionReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_divertingNr) && !m_divertingNr.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_originalCalledNr) && !m_originalCalledNr.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_redirectingInfo) && !m_redirectingInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_originalCalledInfo) && !m_originalCalledInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extension) && !m_extension.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H4503_DivertingLegInfo2Arg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_diversionCounter.Encode(strm);
  m_diversionReason.Encode(strm);
  if (HasOptionalField(e_originalDiversionReason))
    m_originalDiversionReason.Encode(strm);
  if (HasOptionalField(e_divertingNr))
    m_divertingNr.Encode(strm);
  if (HasOptionalField(e_originalCalledNr))
    m_originalCalledNr.Encode(strm);
  if (HasOptionalField(e_redirectingInfo))
    m_redirectingInfo.Encode(strm);
  if (HasOptionalField(e_originalCalledInfo))
    m_originalCalledInfo.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H4503_DivertingLegInfo2Arg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H4503_DivertingLegInfo2Arg::Class()), PInvalidCast);
#endif
  return new H4503_DivertingLegInfo2Arg(*this);
}


#endif // if ! H323_DISABLE_H4503


// End of h4503.cxx
