//
// h245_3.cxx
//
// Code automatically generated by asnparse.
//

#include <ptlib.h>
#include "h245.h"

#define new PNEW


#if ! H323_DISABLE_H245

//
// FECData_rfc2733_pktMode_rfc2733diffport
//

H245_FECData_rfc2733_pktMode_rfc2733diffport::H245_FECData_rfc2733_pktMode_rfc2733diffport(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FECData_rfc2733_pktMode_rfc2733diffport::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "protectedChannel = " << setprecision(indent) << m_protectedChannel << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FECData_rfc2733_pktMode_rfc2733diffport::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FECData_rfc2733_pktMode_rfc2733diffport), PInvalidCast);
#endif
  const H245_FECData_rfc2733_pktMode_rfc2733diffport & other = (const H245_FECData_rfc2733_pktMode_rfc2733diffport &)obj;

  Comparison result;

  if ((result = m_protectedChannel.Compare(other.m_protectedChannel)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FECData_rfc2733_pktMode_rfc2733diffport::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedChannel.GetObjectLength();
  return length;
}


BOOL H245_FECData_rfc2733_pktMode_rfc2733diffport::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedChannel.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FECData_rfc2733_pktMode_rfc2733diffport::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedChannel.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FECData_rfc2733_pktMode_rfc2733diffport::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECData_rfc2733_pktMode_rfc2733diffport::Class()), PInvalidCast);
#endif
  return new H245_FECData_rfc2733_pktMode_rfc2733diffport(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECMode_rfc2733Mode_mode_separateStream[]={
      {"differentPort",0}
     ,{"samePort",1}
};
#endif
//
// DepFECMode_rfc2733Mode_mode_separateStream
//

H245_DepFECMode_rfc2733Mode_mode_separateStream::H245_DepFECMode_rfc2733Mode_mode_separateStream(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECMode_rfc2733Mode_mode_separateStream,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECMode_rfc2733Mode_mode_separateStream::operator H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort &() const
#else
H245_DepFECMode_rfc2733Mode_mode_separateStream::operator H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort *)choice;
}


H245_DepFECMode_rfc2733Mode_mode_separateStream::operator const H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECMode_rfc2733Mode_mode_separateStream::operator H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort &() const
#else
H245_DepFECMode_rfc2733Mode_mode_separateStream::operator H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort *)choice;
}


H245_DepFECMode_rfc2733Mode_mode_separateStream::operator const H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort *)choice;
}


BOOL H245_DepFECMode_rfc2733Mode_mode_separateStream::CreateObject()
{
  switch (tag) {
    case e_differentPort :
      choice = new H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort();
      return TRUE;
    case e_samePort :
      choice = new H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECMode_rfc2733Mode_mode_separateStream::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode_rfc2733Mode_mode_separateStream::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode_rfc2733Mode_mode_separateStream(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkResponse_addConnection_responseCode_rejected[]={
      {"connectionsNotAvailable",0}
     ,{"userRejected",1}
};
#endif
//
// MultilinkResponse_addConnection_responseCode_rejected
//

H245_MultilinkResponse_addConnection_responseCode_rejected::H245_MultilinkResponse_addConnection_responseCode_rejected(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkResponse_addConnection_responseCode_rejected,2
#endif
)
{
}


BOOL H245_MultilinkResponse_addConnection_responseCode_rejected::CreateObject()
{
  choice = (tag <= e_userRejected) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MultilinkResponse_addConnection_responseCode_rejected::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection_responseCode_rejected::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection_responseCode_rejected(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount[]={
      {"doOneProgression",0}
     ,{"doContinuousProgressions",1}
     ,{"doOneIndependentProgression",2}
     ,{"doContinuousIndependentProgressions",3}
};
#endif
//
// MiscellaneousCommand_type_progressiveRefinementStart_repeatCount
//

H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount,4
#endif
)
{
}


BOOL H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::CreateObject()
{
  choice = (tag <= e_doContinuousIndependentProgressions) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCCommand_aal_aal1_clockRecovery[]={
      {"nullClockRecovery",0}
     ,{"srtsClockRecovery",1}
     ,{"adaptiveClockRecovery",2}
};
#endif
//
// NewATMVCCommand_aal_aal1_clockRecovery
//

H245_NewATMVCCommand_aal_aal1_clockRecovery::H245_NewATMVCCommand_aal_aal1_clockRecovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCCommand_aal_aal1_clockRecovery,3
#endif
)
{
}


BOOL H245_NewATMVCCommand_aal_aal1_clockRecovery::CreateObject()
{
  choice = (tag <= e_adaptiveClockRecovery) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCCommand_aal_aal1_clockRecovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1_clockRecovery::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1_clockRecovery(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCCommand_aal_aal1_errorCorrection[]={
      {"nullErrorCorrection",0}
     ,{"longInterleaver",1}
     ,{"shortInterleaver",2}
     ,{"errorCorrectionOnly",3}
};
#endif
//
// NewATMVCCommand_aal_aal1_errorCorrection
//

H245_NewATMVCCommand_aal_aal1_errorCorrection::H245_NewATMVCCommand_aal_aal1_errorCorrection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCCommand_aal_aal1_errorCorrection,4
#endif
)
{
}


BOOL H245_NewATMVCCommand_aal_aal1_errorCorrection::CreateObject()
{
  choice = (tag <= e_errorCorrectionOnly) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCCommand_aal_aal1_errorCorrection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1_errorCorrection::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1_errorCorrection(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCIndication_aal_aal1_clockRecovery[]={
      {"nullClockRecovery",0}
     ,{"srtsClockRecovery",1}
     ,{"adaptiveClockRecovery",2}
};
#endif
//
// NewATMVCIndication_aal_aal1_clockRecovery
//

H245_NewATMVCIndication_aal_aal1_clockRecovery::H245_NewATMVCIndication_aal_aal1_clockRecovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCIndication_aal_aal1_clockRecovery,3
#endif
)
{
}


BOOL H245_NewATMVCIndication_aal_aal1_clockRecovery::CreateObject()
{
  choice = (tag <= e_adaptiveClockRecovery) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCIndication_aal_aal1_clockRecovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1_clockRecovery::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1_clockRecovery(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCIndication_aal_aal1_errorCorrection[]={
      {"nullErrorCorrection",0}
     ,{"longInterleaver",1}
     ,{"shortInterleaver",2}
     ,{"errorCorrectionOnly",3}
};
#endif
//
// NewATMVCIndication_aal_aal1_errorCorrection
//

H245_NewATMVCIndication_aal_aal1_errorCorrection::H245_NewATMVCIndication_aal_aal1_errorCorrection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCIndication_aal_aal1_errorCorrection,4
#endif
)
{
}


BOOL H245_NewATMVCIndication_aal_aal1_errorCorrection::CreateObject()
{
  choice = (tag <= e_errorCorrectionOnly) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCIndication_aal_aal1_errorCorrection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1_errorCorrection::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1_errorCorrection(*this);
}


//
// DepFECData_rfc2733_mode_separateStream_differentPort
//

H245_DepFECData_rfc2733_mode_separateStream_differentPort::H245_DepFECData_rfc2733_mode_separateStream_differentPort(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_protectedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_protectedPayloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_DepFECData_rfc2733_mode_separateStream_differentPort::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protectedSessionID = " << setprecision(indent) << m_protectedSessionID << '\n';
  if (HasOptionalField(e_protectedPayloadType))
    strm << setw(indent+23) << "protectedPayloadType = " << setprecision(indent) << m_protectedPayloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECData_rfc2733_mode_separateStream_differentPort::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECData_rfc2733_mode_separateStream_differentPort), PInvalidCast);
#endif
  const H245_DepFECData_rfc2733_mode_separateStream_differentPort & other = (const H245_DepFECData_rfc2733_mode_separateStream_differentPort &)obj;

  Comparison result;

  if ((result = m_protectedSessionID.Compare(other.m_protectedSessionID)) != EqualTo)
    return result;
  if ((result = m_protectedPayloadType.Compare(other.m_protectedPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECData_rfc2733_mode_separateStream_differentPort::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedSessionID.GetObjectLength();
  if (HasOptionalField(e_protectedPayloadType))
    length += m_protectedPayloadType.GetObjectLength();
  return length;
}


BOOL H245_DepFECData_rfc2733_mode_separateStream_differentPort::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedSessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_protectedPayloadType) && !m_protectedPayloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECData_rfc2733_mode_separateStream_differentPort::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedSessionID.Encode(strm);
  if (HasOptionalField(e_protectedPayloadType))
    m_protectedPayloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECData_rfc2733_mode_separateStream_differentPort::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData_rfc2733_mode_separateStream_differentPort::Class()), PInvalidCast);
#endif
  return new H245_DepFECData_rfc2733_mode_separateStream_differentPort(*this);
}


//
// DepFECData_rfc2733_mode_separateStream_samePort
//

H245_DepFECData_rfc2733_mode_separateStream_samePort::H245_DepFECData_rfc2733_mode_separateStream_samePort(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_protectedPayloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_DepFECData_rfc2733_mode_separateStream_samePort::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "protectedPayloadType = " << setprecision(indent) << m_protectedPayloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECData_rfc2733_mode_separateStream_samePort::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECData_rfc2733_mode_separateStream_samePort), PInvalidCast);
#endif
  const H245_DepFECData_rfc2733_mode_separateStream_samePort & other = (const H245_DepFECData_rfc2733_mode_separateStream_samePort &)obj;

  Comparison result;

  if ((result = m_protectedPayloadType.Compare(other.m_protectedPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECData_rfc2733_mode_separateStream_samePort::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedPayloadType.GetObjectLength();
  return length;
}


BOOL H245_DepFECData_rfc2733_mode_separateStream_samePort::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedPayloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECData_rfc2733_mode_separateStream_samePort::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedPayloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECData_rfc2733_mode_separateStream_samePort::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData_rfc2733_mode_separateStream_samePort::Class()), PInvalidCast);
#endif
  return new H245_DepFECData_rfc2733_mode_separateStream_samePort(*this);
}


//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort
//

H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_protectedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_protectedPayloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protectedSessionID = " << setprecision(indent) << m_protectedSessionID << '\n';
  if (HasOptionalField(e_protectedPayloadType))
    strm << setw(indent+23) << "protectedPayloadType = " << setprecision(indent) << m_protectedPayloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort), PInvalidCast);
#endif
  const H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort & other = (const H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort &)obj;

  Comparison result;

  if ((result = m_protectedSessionID.Compare(other.m_protectedSessionID)) != EqualTo)
    return result;
  if ((result = m_protectedPayloadType.Compare(other.m_protectedPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedSessionID.GetObjectLength();
  if (HasOptionalField(e_protectedPayloadType))
    length += m_protectedPayloadType.GetObjectLength();
  return length;
}


BOOL H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedSessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_protectedPayloadType) && !m_protectedPayloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedSessionID.Encode(strm);
  if (HasOptionalField(e_protectedPayloadType))
    m_protectedPayloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode_rfc2733Mode_mode_separateStream_differentPort(*this);
}


//
// DepFECMode_rfc2733Mode_mode_separateStream_samePort
//

H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "protectedType = " << setprecision(indent) << m_protectedType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort), PInvalidCast);
#endif
  const H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort & other = (const H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort &)obj;

  Comparison result;

  if ((result = m_protectedType.Compare(other.m_protectedType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedType.GetObjectLength();
  return length;
}


BOOL H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode_rfc2733Mode_mode_separateStream_samePort(*this);
}


//
// GenericMessage
//

H245_GenericMessage::H245_GenericMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_subMessageIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_GenericMessage::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "messageIdentifier = " << setprecision(indent) << m_messageIdentifier << '\n';
  if (HasOptionalField(e_subMessageIdentifier))
    strm << setw(indent+23) << "subMessageIdentifier = " << setprecision(indent) << m_subMessageIdentifier << '\n';
  if (HasOptionalField(e_messageContent))
    strm << setw(indent+17) << "messageContent = " << setprecision(indent) << m_messageContent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_GenericMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_GenericMessage), PInvalidCast);
#endif
  const H245_GenericMessage & other = (const H245_GenericMessage &)obj;

  Comparison result;

  if ((result = m_messageIdentifier.Compare(other.m_messageIdentifier)) != EqualTo)
    return result;
  if ((result = m_subMessageIdentifier.Compare(other.m_subMessageIdentifier)) != EqualTo)
    return result;
  if ((result = m_messageContent.Compare(other.m_messageContent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GenericMessage::GetDataLength() const
{
  PINDEX length = 0;
  length += m_messageIdentifier.GetObjectLength();
  if (HasOptionalField(e_subMessageIdentifier))
    length += m_subMessageIdentifier.GetObjectLength();
  if (HasOptionalField(e_messageContent))
    length += m_messageContent.GetObjectLength();
  return length;
}


BOOL H245_GenericMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_messageIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subMessageIdentifier) && !m_subMessageIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_messageContent) && !m_messageContent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_GenericMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_messageIdentifier.Encode(strm);
  if (HasOptionalField(e_subMessageIdentifier))
    m_subMessageIdentifier.Encode(strm);
  if (HasOptionalField(e_messageContent))
    m_messageContent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_GenericMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GenericMessage::Class()), PInvalidCast);
#endif
  return new H245_GenericMessage(*this);
}


//
// GenericInformation
//

H245_GenericInformation::H245_GenericInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : H245_GenericMessage(tag, tagClass)
{
}


PObject * H245_GenericInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GenericInformation::Class()), PInvalidCast);
#endif
  return new H245_GenericInformation(*this);
}


//
// NonStandardParameter
//

H245_NonStandardParameter::H245_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NonStandardParameter), PInvalidCast);
#endif
  const H245_NonStandardParameter & other = (const H245_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardIdentifier.GetObjectLength();
  length += m_data.GetObjectLength();
  return length;
}


BOOL H245_NonStandardParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardIdentifier.Decode(strm))
    return FALSE;
  if (!m_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H245_NonStandardParameter(*this);
}


//
// MasterSlaveDeterminationAck
//

H245_MasterSlaveDeterminationAck::H245_MasterSlaveDeterminationAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "decision = " << setprecision(indent) << m_decision << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDeterminationAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MasterSlaveDeterminationAck), PInvalidCast);
#endif
  const H245_MasterSlaveDeterminationAck & other = (const H245_MasterSlaveDeterminationAck &)obj;

  Comparison result;

  if ((result = m_decision.Compare(other.m_decision)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDeterminationAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_decision.GetObjectLength();
  return length;
}


BOOL H245_MasterSlaveDeterminationAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_decision.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MasterSlaveDeterminationAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_decision.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MasterSlaveDeterminationAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationAck::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationAck(*this);
}


//
// MasterSlaveDeterminationReject
//

H245_MasterSlaveDeterminationReject::H245_MasterSlaveDeterminationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDeterminationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MasterSlaveDeterminationReject), PInvalidCast);
#endif
  const H245_MasterSlaveDeterminationReject & other = (const H245_MasterSlaveDeterminationReject &)obj;

  Comparison result;

  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDeterminationReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_MasterSlaveDeterminationReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MasterSlaveDeterminationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MasterSlaveDeterminationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationReject::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationReject(*this);
}


//
// TerminalCapabilitySet
//

H245_TerminalCapabilitySet::H245_TerminalCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
  m_capabilityTable.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_capabilityDescriptors.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySet::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_multiplexCapability))
    strm << setw(indent+22) << "multiplexCapability = " << setprecision(indent) << m_multiplexCapability << '\n';
  if (HasOptionalField(e_capabilityTable))
    strm << setw(indent+18) << "capabilityTable = " << setprecision(indent) << m_capabilityTable << '\n';
  if (HasOptionalField(e_capabilityDescriptors))
    strm << setw(indent+24) << "capabilityDescriptors = " << setprecision(indent) << m_capabilityDescriptors << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySet::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalCapabilitySet), PInvalidCast);
#endif
  const H245_TerminalCapabilitySet & other = (const H245_TerminalCapabilitySet &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_multiplexCapability.Compare(other.m_multiplexCapability)) != EqualTo)
    return result;
  if ((result = m_capabilityTable.Compare(other.m_capabilityTable)) != EqualTo)
    return result;
  if ((result = m_capabilityDescriptors.Compare(other.m_capabilityDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySet::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_multiplexCapability))
    length += m_multiplexCapability.GetObjectLength();
  if (HasOptionalField(e_capabilityTable))
    length += m_capabilityTable.GetObjectLength();
  if (HasOptionalField(e_capabilityDescriptors))
    length += m_capabilityDescriptors.GetObjectLength();
  return length;
}


BOOL H245_TerminalCapabilitySet::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_multiplexCapability) && !m_multiplexCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capabilityTable) && !m_capabilityTable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capabilityDescriptors) && !m_capabilityDescriptors.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySet::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_multiplexCapability))
    m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTable))
    m_capabilityTable.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptors))
    m_capabilityDescriptors.Encode(strm);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySet(*this);
}


//
// CapabilityTableEntry
//

H245_CapabilityTableEntry::H245_CapabilityTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CapabilityTableEntry::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+29) << "capabilityTableEntryNumber = " << setprecision(indent) << m_capabilityTableEntryNumber << '\n';
  if (HasOptionalField(e_capability))
    strm << setw(indent+13) << "capability = " << setprecision(indent) << m_capability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CapabilityTableEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CapabilityTableEntry), PInvalidCast);
#endif
  const H245_CapabilityTableEntry & other = (const H245_CapabilityTableEntry &)obj;

  Comparison result;

  if ((result = m_capabilityTableEntryNumber.Compare(other.m_capabilityTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_capability.Compare(other.m_capability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CapabilityTableEntry::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityTableEntryNumber.GetObjectLength();
  if (HasOptionalField(e_capability))
    length += m_capability.GetObjectLength();
  return length;
}


BOOL H245_CapabilityTableEntry::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityTableEntryNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capability) && !m_capability.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CapabilityTableEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_capability))
    m_capability.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CapabilityTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityTableEntry::Class()), PInvalidCast);
#endif
  return new H245_CapabilityTableEntry(*this);
}


//
// CapabilityDescriptor
//

H245_CapabilityDescriptor::H245_CapabilityDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_simultaneousCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_CapabilityDescriptor::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+29) << "capabilityDescriptorNumber = " << setprecision(indent) << m_capabilityDescriptorNumber << '\n';
  if (HasOptionalField(e_simultaneousCapabilities))
    strm << setw(indent+27) << "simultaneousCapabilities = " << setprecision(indent) << m_simultaneousCapabilities << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CapabilityDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CapabilityDescriptor), PInvalidCast);
#endif
  const H245_CapabilityDescriptor & other = (const H245_CapabilityDescriptor &)obj;

  Comparison result;

  if ((result = m_capabilityDescriptorNumber.Compare(other.m_capabilityDescriptorNumber)) != EqualTo)
    return result;
  if ((result = m_simultaneousCapabilities.Compare(other.m_simultaneousCapabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CapabilityDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityDescriptorNumber.GetObjectLength();
  if (HasOptionalField(e_simultaneousCapabilities))
    length += m_simultaneousCapabilities.GetObjectLength();
  return length;
}


BOOL H245_CapabilityDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityDescriptorNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_simultaneousCapabilities) && !m_simultaneousCapabilities.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CapabilityDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityDescriptorNumber.Encode(strm);
  if (HasOptionalField(e_simultaneousCapabilities))
    m_simultaneousCapabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CapabilityDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityDescriptor::Class()), PInvalidCast);
#endif
  return new H245_CapabilityDescriptor(*this);
}


//
// TerminalCapabilitySetAck
//

H245_TerminalCapabilitySetAck::H245_TerminalCapabilitySetAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySetAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalCapabilitySetAck), PInvalidCast);
#endif
  const H245_TerminalCapabilitySetAck & other = (const H245_TerminalCapabilitySetAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySetAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  return length;
}


BOOL H245_TerminalCapabilitySetAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySetAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetAck(*this);
}


//
// TerminalCapabilitySetReject
//

H245_TerminalCapabilitySetReject::H245_TerminalCapabilitySetReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySetReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalCapabilitySetReject), PInvalidCast);
#endif
  const H245_TerminalCapabilitySetReject & other = (const H245_TerminalCapabilitySetReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySetReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_TerminalCapabilitySetReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySetReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject(*this);
}


//
// TerminalCapabilitySetRelease
//

H245_TerminalCapabilitySetRelease::H245_TerminalCapabilitySetRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetRelease::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_TerminalCapabilitySetRelease::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_TerminalCapabilitySetRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySetRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetRelease::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetRelease(*this);
}


//
// H222Capability
//

H245_H222Capability::H245_H222Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfVCs.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_H222Capability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "numberOfVCs = " << setprecision(indent) << m_numberOfVCs << '\n';
  strm << setw(indent+15) << "vcCapability = " << setprecision(indent) << m_vcCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H222Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H222Capability), PInvalidCast);
#endif
  const H245_H222Capability & other = (const H245_H222Capability &)obj;

  Comparison result;

  if ((result = m_numberOfVCs.Compare(other.m_numberOfVCs)) != EqualTo)
    return result;
  if ((result = m_vcCapability.Compare(other.m_vcCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H222Capability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numberOfVCs.GetObjectLength();
  length += m_vcCapability.GetObjectLength();
  return length;
}


BOOL H245_H222Capability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numberOfVCs.Decode(strm))
    return FALSE;
  if (!m_vcCapability.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H222Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfVCs.Encode(strm);
  m_vcCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H222Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H222Capability::Class()), PInvalidCast);
#endif
  return new H245_H222Capability(*this);
}


//
// H223Capability
//

H245_H223Capability::H245_H223Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 6)
{
  m_maximumAl2SDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAl3SDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumDelayJitter.SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
  IncludeOptionalField(e_maxMUXPDUSizeCapability);
  IncludeOptionalField(e_nsrpSupport);
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
}


#ifndef PASN_NOPRINTON
void H245_H223Capability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "transportWithI_frames = " << setprecision(indent) << m_transportWithI_frames << '\n';
  strm << setw(indent+15) << "videoWithAL1 = " << setprecision(indent) << m_videoWithAL1 << '\n';
  strm << setw(indent+15) << "videoWithAL2 = " << setprecision(indent) << m_videoWithAL2 << '\n';
  strm << setw(indent+15) << "videoWithAL3 = " << setprecision(indent) << m_videoWithAL3 << '\n';
  strm << setw(indent+15) << "audioWithAL1 = " << setprecision(indent) << m_audioWithAL1 << '\n';
  strm << setw(indent+15) << "audioWithAL2 = " << setprecision(indent) << m_audioWithAL2 << '\n';
  strm << setw(indent+15) << "audioWithAL3 = " << setprecision(indent) << m_audioWithAL3 << '\n';
  strm << setw(indent+14) << "dataWithAL1 = " << setprecision(indent) << m_dataWithAL1 << '\n';
  strm << setw(indent+14) << "dataWithAL2 = " << setprecision(indent) << m_dataWithAL2 << '\n';
  strm << setw(indent+14) << "dataWithAL3 = " << setprecision(indent) << m_dataWithAL3 << '\n';
  strm << setw(indent+20) << "maximumAl2SDUSize = " << setprecision(indent) << m_maximumAl2SDUSize << '\n';
  strm << setw(indent+20) << "maximumAl3SDUSize = " << setprecision(indent) << m_maximumAl3SDUSize << '\n';
  strm << setw(indent+21) << "maximumDelayJitter = " << setprecision(indent) << m_maximumDelayJitter << '\n';
  strm << setw(indent+31) << "h223MultiplexTableCapability = " << setprecision(indent) << m_h223MultiplexTableCapability << '\n';
  if (HasOptionalField(e_maxMUXPDUSizeCapability))
    strm << setw(indent+26) << "maxMUXPDUSizeCapability = " << setprecision(indent) << m_maxMUXPDUSizeCapability << '\n';
  if (HasOptionalField(e_nsrpSupport))
    strm << setw(indent+14) << "nsrpSupport = " << setprecision(indent) << m_nsrpSupport << '\n';
  if (HasOptionalField(e_mobileOperationTransmitCapability))
    strm << setw(indent+36) << "mobileOperationTransmitCapability = " << setprecision(indent) << m_mobileOperationTransmitCapability << '\n';
  if (HasOptionalField(e_h223AnnexCCapability))
    strm << setw(indent+23) << "h223AnnexCCapability = " << setprecision(indent) << m_h223AnnexCCapability << '\n';
  if (HasOptionalField(e_bitRate))
    strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  if (HasOptionalField(e_mobileMultilinkFrameCapability))
    strm << setw(indent+33) << "mobileMultilinkFrameCapability = " << setprecision(indent) << m_mobileMultilinkFrameCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223Capability), PInvalidCast);
#endif
  const H245_H223Capability & other = (const H245_H223Capability &)obj;

  Comparison result;

  if ((result = m_transportWithI_frames.Compare(other.m_transportWithI_frames)) != EqualTo)
    return result;
  if ((result = m_videoWithAL1.Compare(other.m_videoWithAL1)) != EqualTo)
    return result;
  if ((result = m_videoWithAL2.Compare(other.m_videoWithAL2)) != EqualTo)
    return result;
  if ((result = m_videoWithAL3.Compare(other.m_videoWithAL3)) != EqualTo)
    return result;
  if ((result = m_audioWithAL1.Compare(other.m_audioWithAL1)) != EqualTo)
    return result;
  if ((result = m_audioWithAL2.Compare(other.m_audioWithAL2)) != EqualTo)
    return result;
  if ((result = m_audioWithAL3.Compare(other.m_audioWithAL3)) != EqualTo)
    return result;
  if ((result = m_dataWithAL1.Compare(other.m_dataWithAL1)) != EqualTo)
    return result;
  if ((result = m_dataWithAL2.Compare(other.m_dataWithAL2)) != EqualTo)
    return result;
  if ((result = m_dataWithAL3.Compare(other.m_dataWithAL3)) != EqualTo)
    return result;
  if ((result = m_maximumAl2SDUSize.Compare(other.m_maximumAl2SDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAl3SDUSize.Compare(other.m_maximumAl3SDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumDelayJitter.Compare(other.m_maximumDelayJitter)) != EqualTo)
    return result;
  if ((result = m_h223MultiplexTableCapability.Compare(other.m_h223MultiplexTableCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transportWithI_frames.GetObjectLength();
  length += m_videoWithAL1.GetObjectLength();
  length += m_videoWithAL2.GetObjectLength();
  length += m_videoWithAL3.GetObjectLength();
  length += m_audioWithAL1.GetObjectLength();
  length += m_audioWithAL2.GetObjectLength();
  length += m_audioWithAL3.GetObjectLength();
  length += m_dataWithAL1.GetObjectLength();
  length += m_dataWithAL2.GetObjectLength();
  length += m_dataWithAL3.GetObjectLength();
  length += m_maximumAl2SDUSize.GetObjectLength();
  length += m_maximumAl3SDUSize.GetObjectLength();
  length += m_maximumDelayJitter.GetObjectLength();
  length += m_h223MultiplexTableCapability.GetObjectLength();
  return length;
}


BOOL H245_H223Capability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transportWithI_frames.Decode(strm))
    return FALSE;
  if (!m_videoWithAL1.Decode(strm))
    return FALSE;
  if (!m_videoWithAL2.Decode(strm))
    return FALSE;
  if (!m_videoWithAL3.Decode(strm))
    return FALSE;
  if (!m_audioWithAL1.Decode(strm))
    return FALSE;
  if (!m_audioWithAL2.Decode(strm))
    return FALSE;
  if (!m_audioWithAL3.Decode(strm))
    return FALSE;
  if (!m_dataWithAL1.Decode(strm))
    return FALSE;
  if (!m_dataWithAL2.Decode(strm))
    return FALSE;
  if (!m_dataWithAL3.Decode(strm))
    return FALSE;
  if (!m_maximumAl2SDUSize.Decode(strm))
    return FALSE;
  if (!m_maximumAl3SDUSize.Decode(strm))
    return FALSE;
  if (!m_maximumDelayJitter.Decode(strm))
    return FALSE;
  if (!m_h223MultiplexTableCapability.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maxMUXPDUSizeCapability, m_maxMUXPDUSizeCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_nsrpSupport, m_nsrpSupport))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_mobileOperationTransmitCapability, m_mobileOperationTransmitCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h223AnnexCCapability, m_h223AnnexCCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_bitRate, m_bitRate))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_mobileMultilinkFrameCapability, m_mobileMultilinkFrameCapability))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transportWithI_frames.Encode(strm);
  m_videoWithAL1.Encode(strm);
  m_videoWithAL2.Encode(strm);
  m_videoWithAL3.Encode(strm);
  m_audioWithAL1.Encode(strm);
  m_audioWithAL2.Encode(strm);
  m_audioWithAL3.Encode(strm);
  m_dataWithAL1.Encode(strm);
  m_dataWithAL2.Encode(strm);
  m_dataWithAL3.Encode(strm);
  m_maximumAl2SDUSize.Encode(strm);
  m_maximumAl3SDUSize.Encode(strm);
  m_maximumDelayJitter.Encode(strm);
  m_h223MultiplexTableCapability.Encode(strm);
  KnownExtensionEncode(strm, e_maxMUXPDUSizeCapability, m_maxMUXPDUSizeCapability);
  KnownExtensionEncode(strm, e_nsrpSupport, m_nsrpSupport);
  KnownExtensionEncode(strm, e_mobileOperationTransmitCapability, m_mobileOperationTransmitCapability);
  KnownExtensionEncode(strm, e_h223AnnexCCapability, m_h223AnnexCCapability);
  KnownExtensionEncode(strm, e_bitRate, m_bitRate);
  KnownExtensionEncode(strm, e_mobileMultilinkFrameCapability, m_mobileMultilinkFrameCapability);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability(*this);
}


//
// V76Capability
//

H245_V76Capability::H245_V76Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numOfDLCS.SetConstraints(PASN_Object::FixedConstraint, 2, 8191);
  m_n401Capability.SetConstraints(PASN_Object::FixedConstraint, 1, 4095);
  m_maxWindowSizeCapability.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
}


#ifndef PASN_NOPRINTON
void H245_V76Capability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+34) << "suspendResumeCapabilitywAddress = " << setprecision(indent) << m_suspendResumeCapabilitywAddress << '\n';
  strm << setw(indent+35) << "suspendResumeCapabilitywoAddress = " << setprecision(indent) << m_suspendResumeCapabilitywoAddress << '\n';
  strm << setw(indent+16) << "rejCapability = " << setprecision(indent) << m_rejCapability << '\n';
  strm << setw(indent+17) << "sREJCapability = " << setprecision(indent) << m_sREJCapability << '\n';
  strm << setw(indent+17) << "mREJCapability = " << setprecision(indent) << m_mREJCapability << '\n';
  strm << setw(indent+20) << "crc8bitCapability = " << setprecision(indent) << m_crc8bitCapability << '\n';
  strm << setw(indent+21) << "crc16bitCapability = " << setprecision(indent) << m_crc16bitCapability << '\n';
  strm << setw(indent+21) << "crc32bitCapability = " << setprecision(indent) << m_crc32bitCapability << '\n';
  strm << setw(indent+16) << "uihCapability = " << setprecision(indent) << m_uihCapability << '\n';
  strm << setw(indent+12) << "numOfDLCS = " << setprecision(indent) << m_numOfDLCS << '\n';
  strm << setw(indent+33) << "twoOctetAddressFieldCapability = " << setprecision(indent) << m_twoOctetAddressFieldCapability << '\n';
  strm << setw(indent+25) << "loopBackTestCapability = " << setprecision(indent) << m_loopBackTestCapability << '\n';
  strm << setw(indent+17) << "n401Capability = " << setprecision(indent) << m_n401Capability << '\n';
  strm << setw(indent+26) << "maxWindowSizeCapability = " << setprecision(indent) << m_maxWindowSizeCapability << '\n';
  strm << setw(indent+16) << "v75Capability = " << setprecision(indent) << m_v75Capability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V76Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V76Capability), PInvalidCast);
#endif
  const H245_V76Capability & other = (const H245_V76Capability &)obj;

  Comparison result;

  if ((result = m_suspendResumeCapabilitywAddress.Compare(other.m_suspendResumeCapabilitywAddress)) != EqualTo)
    return result;
  if ((result = m_suspendResumeCapabilitywoAddress.Compare(other.m_suspendResumeCapabilitywoAddress)) != EqualTo)
    return result;
  if ((result = m_rejCapability.Compare(other.m_rejCapability)) != EqualTo)
    return result;
  if ((result = m_sREJCapability.Compare(other.m_sREJCapability)) != EqualTo)
    return result;
  if ((result = m_mREJCapability.Compare(other.m_mREJCapability)) != EqualTo)
    return result;
  if ((result = m_crc8bitCapability.Compare(other.m_crc8bitCapability)) != EqualTo)
    return result;
  if ((result = m_crc16bitCapability.Compare(other.m_crc16bitCapability)) != EqualTo)
    return result;
  if ((result = m_crc32bitCapability.Compare(other.m_crc32bitCapability)) != EqualTo)
    return result;
  if ((result = m_uihCapability.Compare(other.m_uihCapability)) != EqualTo)
    return result;
  if ((result = m_numOfDLCS.Compare(other.m_numOfDLCS)) != EqualTo)
    return result;
  if ((result = m_twoOctetAddressFieldCapability.Compare(other.m_twoOctetAddressFieldCapability)) != EqualTo)
    return result;
  if ((result = m_loopBackTestCapability.Compare(other.m_loopBackTestCapability)) != EqualTo)
    return result;
  if ((result = m_n401Capability.Compare(other.m_n401Capability)) != EqualTo)
    return result;
  if ((result = m_maxWindowSizeCapability.Compare(other.m_maxWindowSizeCapability)) != EqualTo)
    return result;
  if ((result = m_v75Capability.Compare(other.m_v75Capability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76Capability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_suspendResumeCapabilitywAddress.GetObjectLength();
  length += m_suspendResumeCapabilitywoAddress.GetObjectLength();
  length += m_rejCapability.GetObjectLength();
  length += m_sREJCapability.GetObjectLength();
  length += m_mREJCapability.GetObjectLength();
  length += m_crc8bitCapability.GetObjectLength();
  length += m_crc16bitCapability.GetObjectLength();
  length += m_crc32bitCapability.GetObjectLength();
  length += m_uihCapability.GetObjectLength();
  length += m_numOfDLCS.GetObjectLength();
  length += m_twoOctetAddressFieldCapability.GetObjectLength();
  length += m_loopBackTestCapability.GetObjectLength();
  length += m_n401Capability.GetObjectLength();
  length += m_maxWindowSizeCapability.GetObjectLength();
  length += m_v75Capability.GetObjectLength();
  return length;
}


BOOL H245_V76Capability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_suspendResumeCapabilitywAddress.Decode(strm))
    return FALSE;
  if (!m_suspendResumeCapabilitywoAddress.Decode(strm))
    return FALSE;
  if (!m_rejCapability.Decode(strm))
    return FALSE;
  if (!m_sREJCapability.Decode(strm))
    return FALSE;
  if (!m_mREJCapability.Decode(strm))
    return FALSE;
  if (!m_crc8bitCapability.Decode(strm))
    return FALSE;
  if (!m_crc16bitCapability.Decode(strm))
    return FALSE;
  if (!m_crc32bitCapability.Decode(strm))
    return FALSE;
  if (!m_uihCapability.Decode(strm))
    return FALSE;
  if (!m_numOfDLCS.Decode(strm))
    return FALSE;
  if (!m_twoOctetAddressFieldCapability.Decode(strm))
    return FALSE;
  if (!m_loopBackTestCapability.Decode(strm))
    return FALSE;
  if (!m_n401Capability.Decode(strm))
    return FALSE;
  if (!m_maxWindowSizeCapability.Decode(strm))
    return FALSE;
  if (!m_v75Capability.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V76Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_suspendResumeCapabilitywAddress.Encode(strm);
  m_suspendResumeCapabilitywoAddress.Encode(strm);
  m_rejCapability.Encode(strm);
  m_sREJCapability.Encode(strm);
  m_mREJCapability.Encode(strm);
  m_crc8bitCapability.Encode(strm);
  m_crc16bitCapability.Encode(strm);
  m_crc32bitCapability.Encode(strm);
  m_uihCapability.Encode(strm);
  m_numOfDLCS.Encode(strm);
  m_twoOctetAddressFieldCapability.Encode(strm);
  m_loopBackTestCapability.Encode(strm);
  m_n401Capability.Encode(strm);
  m_maxWindowSizeCapability.Encode(strm);
  m_v75Capability.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V76Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76Capability::Class()), PInvalidCast);
#endif
  return new H245_V76Capability(*this);
}


//
// MediaPacketizationCapability
//

H245_MediaPacketizationCapability::H245_MediaPacketizationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_rtpPayloadType.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MediaPacketizationCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h261aVideoPacketization = " << setprecision(indent) << m_h261aVideoPacketization << '\n';
  if (HasOptionalField(e_rtpPayloadType))
    strm << setw(indent+17) << "rtpPayloadType = " << setprecision(indent) << m_rtpPayloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MediaPacketizationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MediaPacketizationCapability), PInvalidCast);
#endif
  const H245_MediaPacketizationCapability & other = (const H245_MediaPacketizationCapability &)obj;

  Comparison result;

  if ((result = m_h261aVideoPacketization.Compare(other.m_h261aVideoPacketization)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaPacketizationCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h261aVideoPacketization.GetObjectLength();
  return length;
}


BOOL H245_MediaPacketizationCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h261aVideoPacketization.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rtpPayloadType, m_rtpPayloadType))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MediaPacketizationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h261aVideoPacketization.Encode(strm);
  KnownExtensionEncode(strm, e_rtpPayloadType, m_rtpPayloadType);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MediaPacketizationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaPacketizationCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaPacketizationCapability(*this);
}


//
// RSVPParameters
//

H245_RSVPParameters::H245_RSVPParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_tokenRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_bucketSize.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_peakRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_minPoliced.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_maxPktSize.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_RSVPParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_qosMode))
    strm << setw(indent+10) << "qosMode = " << setprecision(indent) << m_qosMode << '\n';
  if (HasOptionalField(e_tokenRate))
    strm << setw(indent+12) << "tokenRate = " << setprecision(indent) << m_tokenRate << '\n';
  if (HasOptionalField(e_bucketSize))
    strm << setw(indent+13) << "bucketSize = " << setprecision(indent) << m_bucketSize << '\n';
  if (HasOptionalField(e_peakRate))
    strm << setw(indent+11) << "peakRate = " << setprecision(indent) << m_peakRate << '\n';
  if (HasOptionalField(e_minPoliced))
    strm << setw(indent+13) << "minPoliced = " << setprecision(indent) << m_minPoliced << '\n';
  if (HasOptionalField(e_maxPktSize))
    strm << setw(indent+13) << "maxPktSize = " << setprecision(indent) << m_maxPktSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RSVPParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RSVPParameters), PInvalidCast);
#endif
  const H245_RSVPParameters & other = (const H245_RSVPParameters &)obj;

  Comparison result;

  if ((result = m_qosMode.Compare(other.m_qosMode)) != EqualTo)
    return result;
  if ((result = m_tokenRate.Compare(other.m_tokenRate)) != EqualTo)
    return result;
  if ((result = m_bucketSize.Compare(other.m_bucketSize)) != EqualTo)
    return result;
  if ((result = m_peakRate.Compare(other.m_peakRate)) != EqualTo)
    return result;
  if ((result = m_minPoliced.Compare(other.m_minPoliced)) != EqualTo)
    return result;
  if ((result = m_maxPktSize.Compare(other.m_maxPktSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RSVPParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_qosMode))
    length += m_qosMode.GetObjectLength();
  if (HasOptionalField(e_tokenRate))
    length += m_tokenRate.GetObjectLength();
  if (HasOptionalField(e_bucketSize))
    length += m_bucketSize.GetObjectLength();
  if (HasOptionalField(e_peakRate))
    length += m_peakRate.GetObjectLength();
  if (HasOptionalField(e_minPoliced))
    length += m_minPoliced.GetObjectLength();
  if (HasOptionalField(e_maxPktSize))
    length += m_maxPktSize.GetObjectLength();
  return length;
}


BOOL H245_RSVPParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_qosMode) && !m_qosMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokenRate) && !m_tokenRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_bucketSize) && !m_bucketSize.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_peakRate) && !m_peakRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_minPoliced) && !m_minPoliced.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_maxPktSize) && !m_maxPktSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RSVPParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_qosMode))
    m_qosMode.Encode(strm);
  if (HasOptionalField(e_tokenRate))
    m_tokenRate.Encode(strm);
  if (HasOptionalField(e_bucketSize))
    m_bucketSize.Encode(strm);
  if (HasOptionalField(e_peakRate))
    m_peakRate.Encode(strm);
  if (HasOptionalField(e_minPoliced))
    m_minPoliced.Encode(strm);
  if (HasOptionalField(e_maxPktSize))
    m_maxPktSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RSVPParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RSVPParameters::Class()), PInvalidCast);
#endif
  return new H245_RSVPParameters(*this);
}


//
// ServicePriorityValue
//

H245_ServicePriorityValue::H245_ServicePriorityValue(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ServicePriorityValue::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardParameter))
    strm << setw(indent+23) << "nonStandardParameter = " << setprecision(indent) << m_nonStandardParameter << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ServicePriorityValue::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ServicePriorityValue), PInvalidCast);
#endif
  const H245_ServicePriorityValue & other = (const H245_ServicePriorityValue &)obj;

  Comparison result;

  if ((result = m_nonStandardParameter.Compare(other.m_nonStandardParameter)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ServicePriorityValue::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardParameter))
    length += m_nonStandardParameter.GetObjectLength();
  return length;
}


BOOL H245_ServicePriorityValue::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardParameter) && !m_nonStandardParameter.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ServicePriorityValue::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardParameter))
    m_nonStandardParameter.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ServicePriorityValue::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ServicePriorityValue::Class()), PInvalidCast);
#endif
  return new H245_ServicePriorityValue(*this);
}


//
// ServicePriority
//

H245_ServicePriority::H245_ServicePriority(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ServicePriority::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+27) << "servicePrioritySignalled = " << setprecision(indent) << m_servicePrioritySignalled << '\n';
  if (HasOptionalField(e_servicePriorityValue))
    strm << setw(indent+23) << "servicePriorityValue = " << setprecision(indent) << m_servicePriorityValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ServicePriority::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ServicePriority), PInvalidCast);
#endif
  const H245_ServicePriority & other = (const H245_ServicePriority &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_servicePrioritySignalled.Compare(other.m_servicePrioritySignalled)) != EqualTo)
    return result;
  if ((result = m_servicePriorityValue.Compare(other.m_servicePriorityValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ServicePriority::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_servicePrioritySignalled.GetObjectLength();
  if (HasOptionalField(e_servicePriorityValue))
    length += m_servicePriorityValue.GetObjectLength();
  return length;
}


BOOL H245_ServicePriority::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_servicePrioritySignalled.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_servicePriorityValue) && !m_servicePriorityValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ServicePriority::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_servicePrioritySignalled.Encode(strm);
  if (HasOptionalField(e_servicePriorityValue))
    m_servicePriorityValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ServicePriority::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ServicePriority::Class()), PInvalidCast);
#endif
  return new H245_ServicePriority(*this);
}


//
// AuthorizationParameters
//

H245_AuthorizationParameters::H245_AuthorizationParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_AuthorizationParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_AuthorizationParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_AuthorizationParameters), PInvalidCast);
#endif
  const H245_AuthorizationParameters & other = (const H245_AuthorizationParameters &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AuthorizationParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H245_AuthorizationParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_AuthorizationParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_AuthorizationParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AuthorizationParameters::Class()), PInvalidCast);
#endif
  return new H245_AuthorizationParameters(*this);
}


//
// QOSDescriptor
//

H245_QOSDescriptor::H245_QOSDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_QOSDescriptor::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+10) << "qosType = " << setprecision(indent) << m_qosType << '\n';
  strm << setw(indent+11) << "qosClass = " << setprecision(indent) << m_qosClass << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_QOSDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_QOSDescriptor), PInvalidCast);
#endif
  const H245_QOSDescriptor & other = (const H245_QOSDescriptor &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_qosType.Compare(other.m_qosType)) != EqualTo)
    return result;
  if ((result = m_qosClass.Compare(other.m_qosClass)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_QOSDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_qosType.GetObjectLength();
  length += m_qosClass.GetObjectLength();
  return length;
}


BOOL H245_QOSDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_qosType.Decode(strm))
    return FALSE;
  if (!m_qosClass.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_QOSDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_qosType.Encode(strm);
  m_qosClass.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_QOSDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_QOSDescriptor::Class()), PInvalidCast);
#endif
  return new H245_QOSDescriptor(*this);
}


//
// GenericTransportParameters
//

H245_GenericTransportParameters::H245_GenericTransportParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_averageRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_burst.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_peakRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_maxPktSize.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_GenericTransportParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_averageRate))
    strm << setw(indent+14) << "averageRate = " << setprecision(indent) << m_averageRate << '\n';
  if (HasOptionalField(e_burst))
    strm << setw(indent+8) << "burst = " << setprecision(indent) << m_burst << '\n';
  if (HasOptionalField(e_peakRate))
    strm << setw(indent+11) << "peakRate = " << setprecision(indent) << m_peakRate << '\n';
  if (HasOptionalField(e_maxPktSize))
    strm << setw(indent+13) << "maxPktSize = " << setprecision(indent) << m_maxPktSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_GenericTransportParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_GenericTransportParameters), PInvalidCast);
#endif
  const H245_GenericTransportParameters & other = (const H245_GenericTransportParameters &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_averageRate.Compare(other.m_averageRate)) != EqualTo)
    return result;
  if ((result = m_burst.Compare(other.m_burst)) != EqualTo)
    return result;
  if ((result = m_peakRate.Compare(other.m_peakRate)) != EqualTo)
    return result;
  if ((result = m_maxPktSize.Compare(other.m_maxPktSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GenericTransportParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_averageRate))
    length += m_averageRate.GetObjectLength();
  if (HasOptionalField(e_burst))
    length += m_burst.GetObjectLength();
  if (HasOptionalField(e_peakRate))
    length += m_peakRate.GetObjectLength();
  if (HasOptionalField(e_maxPktSize))
    length += m_maxPktSize.GetObjectLength();
  return length;
}


BOOL H245_GenericTransportParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_averageRate) && !m_averageRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_burst) && !m_burst.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_peakRate) && !m_peakRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_maxPktSize) && !m_maxPktSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_GenericTransportParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_averageRate))
    m_averageRate.Encode(strm);
  if (HasOptionalField(e_burst))
    m_burst.Encode(strm);
  if (HasOptionalField(e_peakRate))
    m_peakRate.Encode(strm);
  if (HasOptionalField(e_maxPktSize))
    m_maxPktSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_GenericTransportParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GenericTransportParameters::Class()), PInvalidCast);
#endif
  return new H245_GenericTransportParameters(*this);
}


//
// QOSCapability
//

H245_QOSCapability::H245_QOSCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 6)
{
  m_dscpValue.SetConstraints(PASN_Object::FixedConstraint, 0, 63);
}


#ifndef PASN_NOPRINTON
void H245_QOSCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_rsvpParameters))
    strm << setw(indent+17) << "rsvpParameters = " << setprecision(indent) << m_rsvpParameters << '\n';
  if (HasOptionalField(e_atmParameters))
    strm << setw(indent+16) << "atmParameters = " << setprecision(indent) << m_atmParameters << '\n';
  if (HasOptionalField(e_localQoS))
    strm << setw(indent+11) << "localQoS = " << setprecision(indent) << m_localQoS << '\n';
  if (HasOptionalField(e_genericTransportParameters))
    strm << setw(indent+29) << "genericTransportParameters = " << setprecision(indent) << m_genericTransportParameters << '\n';
  if (HasOptionalField(e_servicePriority))
    strm << setw(indent+18) << "servicePriority = " << setprecision(indent) << m_servicePriority << '\n';
  if (HasOptionalField(e_authorizationParameter))
    strm << setw(indent+25) << "authorizationParameter = " << setprecision(indent) << m_authorizationParameter << '\n';
  if (HasOptionalField(e_qosDescriptor))
    strm << setw(indent+16) << "qosDescriptor = " << setprecision(indent) << m_qosDescriptor << '\n';
  if (HasOptionalField(e_dscpValue))
    strm << setw(indent+12) << "dscpValue = " << setprecision(indent) << m_dscpValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_QOSCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_QOSCapability), PInvalidCast);
#endif
  const H245_QOSCapability & other = (const H245_QOSCapability &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rsvpParameters.Compare(other.m_rsvpParameters)) != EqualTo)
    return result;
  if ((result = m_atmParameters.Compare(other.m_atmParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_QOSCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_rsvpParameters))
    length += m_rsvpParameters.GetObjectLength();
  if (HasOptionalField(e_atmParameters))
    length += m_atmParameters.GetObjectLength();
  return length;
}


BOOL H245_QOSCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rsvpParameters) && !m_rsvpParameters.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_atmParameters) && !m_atmParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_localQoS, m_localQoS))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericTransportParameters, m_genericTransportParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_servicePriority, m_servicePriority))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_authorizationParameter, m_authorizationParameter))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_qosDescriptor, m_qosDescriptor))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dscpValue, m_dscpValue))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_QOSCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_rsvpParameters))
    m_rsvpParameters.Encode(strm);
  if (HasOptionalField(e_atmParameters))
    m_atmParameters.Encode(strm);
  KnownExtensionEncode(strm, e_localQoS, m_localQoS);
  KnownExtensionEncode(strm, e_genericTransportParameters, m_genericTransportParameters);
  KnownExtensionEncode(strm, e_servicePriority, m_servicePriority);
  KnownExtensionEncode(strm, e_authorizationParameter, m_authorizationParameter);
  KnownExtensionEncode(strm, e_qosDescriptor, m_qosDescriptor);
  KnownExtensionEncode(strm, e_dscpValue, m_dscpValue);

  UnknownExtensionsEncode(strm);
}


PObject * H245_QOSCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_QOSCapability::Class()), PInvalidCast);
#endif
  return new H245_QOSCapability(*this);
}


//
// TransportCapability
//

H245_TransportCapability::H245_TransportCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_qOSCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_mediaChannelCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_TransportCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_qOSCapabilities))
    strm << setw(indent+18) << "qOSCapabilities = " << setprecision(indent) << m_qOSCapabilities << '\n';
  if (HasOptionalField(e_mediaChannelCapabilities))
    strm << setw(indent+27) << "mediaChannelCapabilities = " << setprecision(indent) << m_mediaChannelCapabilities << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TransportCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TransportCapability), PInvalidCast);
#endif
  const H245_TransportCapability & other = (const H245_TransportCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_qOSCapabilities.Compare(other.m_qOSCapabilities)) != EqualTo)
    return result;
  if ((result = m_mediaChannelCapabilities.Compare(other.m_mediaChannelCapabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TransportCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  if (HasOptionalField(e_qOSCapabilities))
    length += m_qOSCapabilities.GetObjectLength();
  if (HasOptionalField(e_mediaChannelCapabilities))
    length += m_mediaChannelCapabilities.GetObjectLength();
  return length;
}


BOOL H245_TransportCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qOSCapabilities) && !m_qOSCapabilities.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaChannelCapabilities) && !m_mediaChannelCapabilities.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TransportCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_qOSCapabilities))
    m_qOSCapabilities.Encode(strm);
  if (HasOptionalField(e_mediaChannelCapabilities))
    m_mediaChannelCapabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TransportCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransportCapability::Class()), PInvalidCast);
#endif
  return new H245_TransportCapability(*this);
}


//
// RedundancyEncodingCapability
//

H245_RedundancyEncodingCapability::H245_RedundancyEncodingCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_secondaryEncoding.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  strm << setw(indent+18) << "primaryEncoding = " << setprecision(indent) << m_primaryEncoding << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncodingCapability), PInvalidCast);
#endif
  const H245_RedundancyEncodingCapability & other = (const H245_RedundancyEncodingCapability &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_primaryEncoding.Compare(other.m_primaryEncoding)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redundancyEncodingMethod.GetObjectLength();
  length += m_primaryEncoding.GetObjectLength();
  if (HasOptionalField(e_secondaryEncoding))
    length += m_secondaryEncoding.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncodingCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_redundancyEncodingMethod.Decode(strm))
    return FALSE;
  if (!m_primaryEncoding.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_secondaryEncoding) && !m_secondaryEncoding.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncodingCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  m_primaryEncoding.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncodingCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingCapability::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingCapability(*this);
}


//
// RTPH263VideoRedundancyEncoding
//

H245_RTPH263VideoRedundancyEncoding::H245_RTPH263VideoRedundancyEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_numberOfThreads.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_framesBetweenSyncPoints.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RTPH263VideoRedundancyEncoding::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "numberOfThreads = " << setprecision(indent) << m_numberOfThreads << '\n';
  strm << setw(indent+26) << "framesBetweenSyncPoints = " << setprecision(indent) << m_framesBetweenSyncPoints << '\n';
  strm << setw(indent+23) << "frameToThreadMapping = " << setprecision(indent) << m_frameToThreadMapping << '\n';
  if (HasOptionalField(e_containedThreads))
    strm << setw(indent+19) << "containedThreads = " << setprecision(indent) << m_containedThreads << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RTPH263VideoRedundancyEncoding::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RTPH263VideoRedundancyEncoding), PInvalidCast);
#endif
  const H245_RTPH263VideoRedundancyEncoding & other = (const H245_RTPH263VideoRedundancyEncoding &)obj;

  Comparison result;

  if ((result = m_numberOfThreads.Compare(other.m_numberOfThreads)) != EqualTo)
    return result;
  if ((result = m_framesBetweenSyncPoints.Compare(other.m_framesBetweenSyncPoints)) != EqualTo)
    return result;
  if ((result = m_frameToThreadMapping.Compare(other.m_frameToThreadMapping)) != EqualTo)
    return result;
  if ((result = m_containedThreads.Compare(other.m_containedThreads)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPH263VideoRedundancyEncoding::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numberOfThreads.GetObjectLength();
  length += m_framesBetweenSyncPoints.GetObjectLength();
  length += m_frameToThreadMapping.GetObjectLength();
  if (HasOptionalField(e_containedThreads))
    length += m_containedThreads.GetObjectLength();
  return length;
}


BOOL H245_RTPH263VideoRedundancyEncoding::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numberOfThreads.Decode(strm))
    return FALSE;
  if (!m_framesBetweenSyncPoints.Decode(strm))
    return FALSE;
  if (!m_frameToThreadMapping.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_containedThreads) && !m_containedThreads.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RTPH263VideoRedundancyEncoding::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfThreads.Encode(strm);
  m_framesBetweenSyncPoints.Encode(strm);
  m_frameToThreadMapping.Encode(strm);
  if (HasOptionalField(e_containedThreads))
    m_containedThreads.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RTPH263VideoRedundancyEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding(*this);
}


//
// RTPH263VideoRedundancyFrameMapping
//

H245_RTPH263VideoRedundancyFrameMapping::H245_RTPH263VideoRedundancyFrameMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_threadNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
}


#ifndef PASN_NOPRINTON
void H245_RTPH263VideoRedundancyFrameMapping::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "threadNumber = " << setprecision(indent) << m_threadNumber << '\n';
  strm << setw(indent+16) << "frameSequence = " << setprecision(indent) << m_frameSequence << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RTPH263VideoRedundancyFrameMapping::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RTPH263VideoRedundancyFrameMapping), PInvalidCast);
#endif
  const H245_RTPH263VideoRedundancyFrameMapping & other = (const H245_RTPH263VideoRedundancyFrameMapping &)obj;

  Comparison result;

  if ((result = m_threadNumber.Compare(other.m_threadNumber)) != EqualTo)
    return result;
  if ((result = m_frameSequence.Compare(other.m_frameSequence)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPH263VideoRedundancyFrameMapping::GetDataLength() const
{
  PINDEX length = 0;
  length += m_threadNumber.GetObjectLength();
  length += m_frameSequence.GetObjectLength();
  return length;
}


BOOL H245_RTPH263VideoRedundancyFrameMapping::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_threadNumber.Decode(strm))
    return FALSE;
  if (!m_frameSequence.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RTPH263VideoRedundancyFrameMapping::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_threadNumber.Encode(strm);
  m_frameSequence.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RTPH263VideoRedundancyFrameMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyFrameMapping(*this);
}


//
// MultipointCapability
//

H245_MultipointCapability::H245_MultipointCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultipointCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "multicastCapability = " << setprecision(indent) << m_multicastCapability << '\n';
  strm << setw(indent+25) << "multiUniCastConference = " << setprecision(indent) << m_multiUniCastConference << '\n';
  strm << setw(indent+30) << "mediaDistributionCapability = " << setprecision(indent) << m_mediaDistributionCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultipointCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultipointCapability), PInvalidCast);
#endif
  const H245_MultipointCapability & other = (const H245_MultipointCapability &)obj;

  Comparison result;

  if ((result = m_multicastCapability.Compare(other.m_multicastCapability)) != EqualTo)
    return result;
  if ((result = m_multiUniCastConference.Compare(other.m_multiUniCastConference)) != EqualTo)
    return result;
  if ((result = m_mediaDistributionCapability.Compare(other.m_mediaDistributionCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultipointCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multicastCapability.GetObjectLength();
  length += m_multiUniCastConference.GetObjectLength();
  length += m_mediaDistributionCapability.GetObjectLength();
  return length;
}


BOOL H245_MultipointCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multicastCapability.Decode(strm))
    return FALSE;
  if (!m_multiUniCastConference.Decode(strm))
    return FALSE;
  if (!m_mediaDistributionCapability.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultipointCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multicastCapability.Encode(strm);
  m_multiUniCastConference.Encode(strm);
  m_mediaDistributionCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultipointCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultipointCapability::Class()), PInvalidCast);
#endif
  return new H245_MultipointCapability(*this);
}


//
// MediaDistributionCapability
//

H245_MediaDistributionCapability::H245_MediaDistributionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MediaDistributionCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "centralizedControl = " << setprecision(indent) << m_centralizedControl << '\n';
  strm << setw(indent+21) << "distributedControl = " << setprecision(indent) << m_distributedControl << '\n';
  strm << setw(indent+19) << "centralizedAudio = " << setprecision(indent) << m_centralizedAudio << '\n';
  strm << setw(indent+19) << "distributedAudio = " << setprecision(indent) << m_distributedAudio << '\n';
  strm << setw(indent+19) << "centralizedVideo = " << setprecision(indent) << m_centralizedVideo << '\n';
  strm << setw(indent+19) << "distributedVideo = " << setprecision(indent) << m_distributedVideo << '\n';
  if (HasOptionalField(e_centralizedData))
    strm << setw(indent+18) << "centralizedData = " << setprecision(indent) << m_centralizedData << '\n';
  if (HasOptionalField(e_distributedData))
    strm << setw(indent+18) << "distributedData = " << setprecision(indent) << m_distributedData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MediaDistributionCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MediaDistributionCapability), PInvalidCast);
#endif
  const H245_MediaDistributionCapability & other = (const H245_MediaDistributionCapability &)obj;

  Comparison result;

  if ((result = m_centralizedControl.Compare(other.m_centralizedControl)) != EqualTo)
    return result;
  if ((result = m_distributedControl.Compare(other.m_distributedControl)) != EqualTo)
    return result;
  if ((result = m_centralizedAudio.Compare(other.m_centralizedAudio)) != EqualTo)
    return result;
  if ((result = m_distributedAudio.Compare(other.m_distributedAudio)) != EqualTo)
    return result;
  if ((result = m_centralizedVideo.Compare(other.m_centralizedVideo)) != EqualTo)
    return result;
  if ((result = m_distributedVideo.Compare(other.m_distributedVideo)) != EqualTo)
    return result;
  if ((result = m_centralizedData.Compare(other.m_centralizedData)) != EqualTo)
    return result;
  if ((result = m_distributedData.Compare(other.m_distributedData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaDistributionCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_centralizedControl.GetObjectLength();
  length += m_distributedControl.GetObjectLength();
  length += m_centralizedAudio.GetObjectLength();
  length += m_distributedAudio.GetObjectLength();
  length += m_centralizedVideo.GetObjectLength();
  length += m_distributedVideo.GetObjectLength();
  if (HasOptionalField(e_centralizedData))
    length += m_centralizedData.GetObjectLength();
  if (HasOptionalField(e_distributedData))
    length += m_distributedData.GetObjectLength();
  return length;
}


BOOL H245_MediaDistributionCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_centralizedControl.Decode(strm))
    return FALSE;
  if (!m_distributedControl.Decode(strm))
    return FALSE;
  if (!m_centralizedAudio.Decode(strm))
    return FALSE;
  if (!m_distributedAudio.Decode(strm))
    return FALSE;
  if (!m_centralizedVideo.Decode(strm))
    return FALSE;
  if (!m_distributedVideo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_centralizedData) && !m_centralizedData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_distributedData) && !m_distributedData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MediaDistributionCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_centralizedControl.Encode(strm);
  m_distributedControl.Encode(strm);
  m_centralizedAudio.Encode(strm);
  m_distributedAudio.Encode(strm);
  m_centralizedVideo.Encode(strm);
  m_distributedVideo.Encode(strm);
  if (HasOptionalField(e_centralizedData))
    m_centralizedData.Encode(strm);
  if (HasOptionalField(e_distributedData))
    m_distributedData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MediaDistributionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaDistributionCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaDistributionCapability(*this);
}


//
// ExtendedVideoCapability
//

H245_ExtendedVideoCapability::H245_ExtendedVideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ExtendedVideoCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "videoCapability = " << setprecision(indent) << m_videoCapability << '\n';
  if (HasOptionalField(e_videoCapabilityExtension))
    strm << setw(indent+27) << "videoCapabilityExtension = " << setprecision(indent) << m_videoCapabilityExtension << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ExtendedVideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ExtendedVideoCapability), PInvalidCast);
#endif
  const H245_ExtendedVideoCapability & other = (const H245_ExtendedVideoCapability &)obj;

  Comparison result;

  if ((result = m_videoCapability.Compare(other.m_videoCapability)) != EqualTo)
    return result;
  if ((result = m_videoCapabilityExtension.Compare(other.m_videoCapabilityExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ExtendedVideoCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_videoCapability.GetObjectLength();
  if (HasOptionalField(e_videoCapabilityExtension))
    length += m_videoCapabilityExtension.GetObjectLength();
  return length;
}


BOOL H245_ExtendedVideoCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_videoCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_videoCapabilityExtension) && !m_videoCapabilityExtension.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ExtendedVideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_videoCapability.Encode(strm);
  if (HasOptionalField(e_videoCapabilityExtension))
    m_videoCapabilityExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ExtendedVideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ExtendedVideoCapability::Class()), PInvalidCast);
#endif
  return new H245_ExtendedVideoCapability(*this);
}


//
// EnhancementLayerInfo
//

H245_EnhancementLayerInfo::H245_EnhancementLayerInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_snrEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  m_spatialEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  m_bPictureEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
}


#ifndef PASN_NOPRINTON
void H245_EnhancementLayerInfo::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "baseBitRateConstrained = " << setprecision(indent) << m_baseBitRateConstrained << '\n';
  if (HasOptionalField(e_snrEnhancement))
    strm << setw(indent+17) << "snrEnhancement = " << setprecision(indent) << m_snrEnhancement << '\n';
  if (HasOptionalField(e_spatialEnhancement))
    strm << setw(indent+21) << "spatialEnhancement = " << setprecision(indent) << m_spatialEnhancement << '\n';
  if (HasOptionalField(e_bPictureEnhancement))
    strm << setw(indent+22) << "bPictureEnhancement = " << setprecision(indent) << m_bPictureEnhancement << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EnhancementLayerInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EnhancementLayerInfo), PInvalidCast);
#endif
  const H245_EnhancementLayerInfo & other = (const H245_EnhancementLayerInfo &)obj;

  Comparison result;

  if ((result = m_baseBitRateConstrained.Compare(other.m_baseBitRateConstrained)) != EqualTo)
    return result;
  if ((result = m_snrEnhancement.Compare(other.m_snrEnhancement)) != EqualTo)
    return result;
  if ((result = m_spatialEnhancement.Compare(other.m_spatialEnhancement)) != EqualTo)
    return result;
  if ((result = m_bPictureEnhancement.Compare(other.m_bPictureEnhancement)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EnhancementLayerInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_baseBitRateConstrained.GetObjectLength();
  if (HasOptionalField(e_snrEnhancement))
    length += m_snrEnhancement.GetObjectLength();
  if (HasOptionalField(e_spatialEnhancement))
    length += m_spatialEnhancement.GetObjectLength();
  if (HasOptionalField(e_bPictureEnhancement))
    length += m_bPictureEnhancement.GetObjectLength();
  return length;
}


BOOL H245_EnhancementLayerInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_baseBitRateConstrained.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_snrEnhancement) && !m_snrEnhancement.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_spatialEnhancement) && !m_spatialEnhancement.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_bPictureEnhancement) && !m_bPictureEnhancement.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EnhancementLayerInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_baseBitRateConstrained.Encode(strm);
  if (HasOptionalField(e_snrEnhancement))
    m_snrEnhancement.Encode(strm);
  if (HasOptionalField(e_spatialEnhancement))
    m_spatialEnhancement.Encode(strm);
  if (HasOptionalField(e_bPictureEnhancement))
    m_bPictureEnhancement.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EnhancementLayerInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EnhancementLayerInfo::Class()), PInvalidCast);
#endif
  return new H245_EnhancementLayerInfo(*this);
}


//
// H263ModeComboFlags
//

H245_H263ModeComboFlags::H245_H263ModeComboFlags(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
  IncludeOptionalField(e_enhancedReferencePicSelect);
  IncludeOptionalField(e_h263Version3Options);
}


#ifndef PASN_NOPRINTON
void H245_H263ModeComboFlags::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  strm << setw(indent+26) << "advancedIntraCodingMode = " << setprecision(indent) << m_advancedIntraCodingMode << '\n';
  strm << setw(indent+23) << "deblockingFilterMode = " << setprecision(indent) << m_deblockingFilterMode << '\n';
  strm << setw(indent+25) << "unlimitedMotionVectors = " << setprecision(indent) << m_unlimitedMotionVectors << '\n';
  strm << setw(indent+24) << "slicesInOrder_NonRect = " << setprecision(indent) << m_slicesInOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesInOrder_Rect = " << setprecision(indent) << m_slicesInOrder_Rect << '\n';
  strm << setw(indent+24) << "slicesNoOrder_NonRect = " << setprecision(indent) << m_slicesNoOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesNoOrder_Rect = " << setprecision(indent) << m_slicesNoOrder_Rect << '\n';
  strm << setw(indent+23) << "improvedPBFramesMode = " << setprecision(indent) << m_improvedPBFramesMode << '\n';
  strm << setw(indent+21) << "referencePicSelect = " << setprecision(indent) << m_referencePicSelect << '\n';
  strm << setw(indent+31) << "dynamicPictureResizingByFour = " << setprecision(indent) << m_dynamicPictureResizingByFour << '\n';
  strm << setw(indent+37) << "dynamicPictureResizingSixteenthPel = " << setprecision(indent) << m_dynamicPictureResizingSixteenthPel << '\n';
  strm << setw(indent+24) << "dynamicWarpingHalfPel = " << setprecision(indent) << m_dynamicWarpingHalfPel << '\n';
  strm << setw(indent+29) << "dynamicWarpingSixteenthPel = " << setprecision(indent) << m_dynamicWarpingSixteenthPel << '\n';
  strm << setw(indent+26) << "reducedResolutionUpdate = " << setprecision(indent) << m_reducedResolutionUpdate << '\n';
  strm << setw(indent+29) << "independentSegmentDecoding = " << setprecision(indent) << m_independentSegmentDecoding << '\n';
  strm << setw(indent+24) << "alternateInterVLCMode = " << setprecision(indent) << m_alternateInterVLCMode << '\n';
  strm << setw(indent+27) << "modifiedQuantizationMode = " << setprecision(indent) << m_modifiedQuantizationMode << '\n';
  if (HasOptionalField(e_enhancedReferencePicSelect))
    strm << setw(indent+29) << "enhancedReferencePicSelect = " << setprecision(indent) << m_enhancedReferencePicSelect << '\n';
  if (HasOptionalField(e_h263Version3Options))
    strm << setw(indent+22) << "h263Version3Options = " << setprecision(indent) << m_h263Version3Options << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263ModeComboFlags::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263ModeComboFlags), PInvalidCast);
#endif
  const H245_H263ModeComboFlags & other = (const H245_H263ModeComboFlags &)obj;

  Comparison result;

  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;
  if ((result = m_advancedIntraCodingMode.Compare(other.m_advancedIntraCodingMode)) != EqualTo)
    return result;
  if ((result = m_deblockingFilterMode.Compare(other.m_deblockingFilterMode)) != EqualTo)
    return result;
  if ((result = m_unlimitedMotionVectors.Compare(other.m_unlimitedMotionVectors)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_NonRect.Compare(other.m_slicesInOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_Rect.Compare(other.m_slicesInOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_NonRect.Compare(other.m_slicesNoOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_Rect.Compare(other.m_slicesNoOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_improvedPBFramesMode.Compare(other.m_improvedPBFramesMode)) != EqualTo)
    return result;
  if ((result = m_referencePicSelect.Compare(other.m_referencePicSelect)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingByFour.Compare(other.m_dynamicPictureResizingByFour)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingSixteenthPel.Compare(other.m_dynamicPictureResizingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingHalfPel.Compare(other.m_dynamicWarpingHalfPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingSixteenthPel.Compare(other.m_dynamicWarpingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_reducedResolutionUpdate.Compare(other.m_reducedResolutionUpdate)) != EqualTo)
    return result;
  if ((result = m_independentSegmentDecoding.Compare(other.m_independentSegmentDecoding)) != EqualTo)
    return result;
  if ((result = m_alternateInterVLCMode.Compare(other.m_alternateInterVLCMode)) != EqualTo)
    return result;
  if ((result = m_modifiedQuantizationMode.Compare(other.m_modifiedQuantizationMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263ModeComboFlags::GetDataLength() const
{
  PINDEX length = 0;
  length += m_unrestrictedVector.GetObjectLength();
  length += m_arithmeticCoding.GetObjectLength();
  length += m_advancedPrediction.GetObjectLength();
  length += m_pbFrames.GetObjectLength();
  length += m_advancedIntraCodingMode.GetObjectLength();
  length += m_deblockingFilterMode.GetObjectLength();
  length += m_unlimitedMotionVectors.GetObjectLength();
  length += m_slicesInOrder_NonRect.GetObjectLength();
  length += m_slicesInOrder_Rect.GetObjectLength();
  length += m_slicesNoOrder_NonRect.GetObjectLength();
  length += m_slicesNoOrder_Rect.GetObjectLength();
  length += m_improvedPBFramesMode.GetObjectLength();
  length += m_referencePicSelect.GetObjectLength();
  length += m_dynamicPictureResizingByFour.GetObjectLength();
  length += m_dynamicPictureResizingSixteenthPel.GetObjectLength();
  length += m_dynamicWarpingHalfPel.GetObjectLength();
  length += m_dynamicWarpingSixteenthPel.GetObjectLength();
  length += m_reducedResolutionUpdate.GetObjectLength();
  length += m_independentSegmentDecoding.GetObjectLength();
  length += m_alternateInterVLCMode.GetObjectLength();
  length += m_modifiedQuantizationMode.GetObjectLength();
  return length;
}


BOOL H245_H263ModeComboFlags::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_unrestrictedVector.Decode(strm))
    return FALSE;
  if (!m_arithmeticCoding.Decode(strm))
    return FALSE;
  if (!m_advancedPrediction.Decode(strm))
    return FALSE;
  if (!m_pbFrames.Decode(strm))
    return FALSE;
  if (!m_advancedIntraCodingMode.Decode(strm))
    return FALSE;
  if (!m_deblockingFilterMode.Decode(strm))
    return FALSE;
  if (!m_unlimitedMotionVectors.Decode(strm))
    return FALSE;
  if (!m_slicesInOrder_NonRect.Decode(strm))
    return FALSE;
  if (!m_slicesInOrder_Rect.Decode(strm))
    return FALSE;
  if (!m_slicesNoOrder_NonRect.Decode(strm))
    return FALSE;
  if (!m_slicesNoOrder_Rect.Decode(strm))
    return FALSE;
  if (!m_improvedPBFramesMode.Decode(strm))
    return FALSE;
  if (!m_referencePicSelect.Decode(strm))
    return FALSE;
  if (!m_dynamicPictureResizingByFour.Decode(strm))
    return FALSE;
  if (!m_dynamicPictureResizingSixteenthPel.Decode(strm))
    return FALSE;
  if (!m_dynamicWarpingHalfPel.Decode(strm))
    return FALSE;
  if (!m_dynamicWarpingSixteenthPel.Decode(strm))
    return FALSE;
  if (!m_reducedResolutionUpdate.Decode(strm))
    return FALSE;
  if (!m_independentSegmentDecoding.Decode(strm))
    return FALSE;
  if (!m_alternateInterVLCMode.Decode(strm))
    return FALSE;
  if (!m_modifiedQuantizationMode.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h263Version3Options, m_h263Version3Options))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263ModeComboFlags::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_referencePicSelect.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);
  KnownExtensionEncode(strm, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect);
  KnownExtensionEncode(strm, e_h263Version3Options, m_h263Version3Options);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263ModeComboFlags::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263ModeComboFlags::Class()), PInvalidCast);
#endif
  return new H245_H263ModeComboFlags(*this);
}


//
// G7231AnnexCCapability
//

H245_G7231AnnexCCapability::H245_G7231AnnexCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  if (HasOptionalField(e_g723AnnexCAudioMode))
    strm << setw(indent+22) << "g723AnnexCAudioMode = " << setprecision(indent) << m_g723AnnexCAudioMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_G7231AnnexCCapability), PInvalidCast);
#endif
  const H245_G7231AnnexCCapability & other = (const H245_G7231AnnexCCapability &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_g723AnnexCAudioMode.Compare(other.m_g723AnnexCAudioMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxAl_sduAudioFrames.GetObjectLength();
  length += m_silenceSuppression.GetObjectLength();
  if (HasOptionalField(e_g723AnnexCAudioMode))
    length += m_g723AnnexCAudioMode.GetObjectLength();
  return length;
}


BOOL H245_G7231AnnexCCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxAl_sduAudioFrames.Decode(strm))
    return FALSE;
  if (!m_silenceSuppression.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_g723AnnexCAudioMode) && !m_g723AnnexCAudioMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_G7231AnnexCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_g723AnnexCAudioMode))
    m_g723AnnexCAudioMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_G7231AnnexCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCCapability::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCCapability(*this);
}


//
// DataApplicationCapability
//

H245_DataApplicationCapability::H245_DataApplicationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "application = " << setprecision(indent) << m_application << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataApplicationCapability), PInvalidCast);
#endif
  const H245_DataApplicationCapability & other = (const H245_DataApplicationCapability &)obj;

  Comparison result;

  if ((result = m_application.Compare(other.m_application)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_application.GetObjectLength();
  length += m_maxBitRate.GetObjectLength();
  return length;
}


BOOL H245_DataApplicationCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_application.Decode(strm))
    return FALSE;
  if (!m_maxBitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataApplicationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_application.Encode(strm);
  m_maxBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataApplicationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability(*this);
}


//
// T38FaxUdpOptions
//

H245_T38FaxUdpOptions::H245_T38FaxUdpOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_T38FaxUdpOptions::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_t38FaxMaxBuffer))
    strm << setw(indent+18) << "t38FaxMaxBuffer = " << setprecision(indent) << m_t38FaxMaxBuffer << '\n';
  if (HasOptionalField(e_t38FaxMaxDatagram))
    strm << setw(indent+20) << "t38FaxMaxDatagram = " << setprecision(indent) << m_t38FaxMaxDatagram << '\n';
  strm << setw(indent+14) << "t38FaxUdpEC = " << setprecision(indent) << m_t38FaxUdpEC << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_T38FaxUdpOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_T38FaxUdpOptions), PInvalidCast);
#endif
  const H245_T38FaxUdpOptions & other = (const H245_T38FaxUdpOptions &)obj;

  Comparison result;

  if ((result = m_t38FaxMaxBuffer.Compare(other.m_t38FaxMaxBuffer)) != EqualTo)
    return result;
  if ((result = m_t38FaxMaxDatagram.Compare(other.m_t38FaxMaxDatagram)) != EqualTo)
    return result;
  if ((result = m_t38FaxUdpEC.Compare(other.m_t38FaxUdpEC)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T38FaxUdpOptions::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_t38FaxMaxBuffer))
    length += m_t38FaxMaxBuffer.GetObjectLength();
  if (HasOptionalField(e_t38FaxMaxDatagram))
    length += m_t38FaxMaxDatagram.GetObjectLength();
  length += m_t38FaxUdpEC.GetObjectLength();
  return length;
}


BOOL H245_T38FaxUdpOptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_t38FaxMaxBuffer) && !m_t38FaxMaxBuffer.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_t38FaxMaxDatagram) && !m_t38FaxMaxDatagram.Decode(strm))
    return FALSE;
  if (!m_t38FaxUdpEC.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_T38FaxUdpOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_t38FaxMaxBuffer))
    m_t38FaxMaxBuffer.Encode(strm);
  if (HasOptionalField(e_t38FaxMaxDatagram))
    m_t38FaxMaxDatagram.Encode(strm);
  m_t38FaxUdpEC.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_T38FaxUdpOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxUdpOptions::Class()), PInvalidCast);
#endif
  return new H245_T38FaxUdpOptions(*this);
}


//
// AuthenticationCapability
//

H245_AuthenticationCapability::H245_AuthenticationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_AuthenticationCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_antiSpamAlgorithm))
    strm << setw(indent+20) << "antiSpamAlgorithm = " << setprecision(indent) << m_antiSpamAlgorithm << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_AuthenticationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_AuthenticationCapability), PInvalidCast);
#endif
  const H245_AuthenticationCapability & other = (const H245_AuthenticationCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AuthenticationCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  return length;
}


BOOL H245_AuthenticationCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_antiSpamAlgorithm, m_antiSpamAlgorithm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_AuthenticationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  KnownExtensionEncode(strm, e_antiSpamAlgorithm, m_antiSpamAlgorithm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_AuthenticationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AuthenticationCapability::Class()), PInvalidCast);
#endif
  return new H245_AuthenticationCapability(*this);
}


//
// IntegrityCapability
//

H245_IntegrityCapability::H245_IntegrityCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_IntegrityCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IntegrityCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IntegrityCapability), PInvalidCast);
#endif
  const H245_IntegrityCapability & other = (const H245_IntegrityCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IntegrityCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  return length;
}


BOOL H245_IntegrityCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IntegrityCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IntegrityCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IntegrityCapability::Class()), PInvalidCast);
#endif
  return new H245_IntegrityCapability(*this);
}


//
// ConferenceCapability
//

H245_ConferenceCapability::H245_ConferenceCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_videoIndicateMixingCapability);
}


#ifndef PASN_NOPRINTON
void H245_ConferenceCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+25) << "chairControlCapability = " << setprecision(indent) << m_chairControlCapability << '\n';
  if (HasOptionalField(e_videoIndicateMixingCapability))
    strm << setw(indent+32) << "videoIndicateMixingCapability = " << setprecision(indent) << m_videoIndicateMixingCapability << '\n';
  if (HasOptionalField(e_multipointVisualizationCapability))
    strm << setw(indent+36) << "multipointVisualizationCapability = " << setprecision(indent) << m_multipointVisualizationCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceCapability), PInvalidCast);
#endif
  const H245_ConferenceCapability & other = (const H245_ConferenceCapability &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_chairControlCapability.Compare(other.m_chairControlCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_chairControlCapability.GetObjectLength();
  return length;
}


BOOL H245_ConferenceCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_chairControlCapability.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_videoIndicateMixingCapability, m_videoIndicateMixingCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipointVisualizationCapability, m_multipointVisualizationCapability))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_chairControlCapability.Encode(strm);
  KnownExtensionEncode(strm, e_videoIndicateMixingCapability, m_videoIndicateMixingCapability);
  KnownExtensionEncode(strm, e_multipointVisualizationCapability, m_multipointVisualizationCapability);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceCapability::Class()), PInvalidCast);
#endif
  return new H245_ConferenceCapability(*this);
}


//
// GenericCapability
//

H245_GenericCapability::H245_GenericCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_GenericCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "capabilityIdentifier = " << setprecision(indent) << m_capabilityIdentifier << '\n';
  if (HasOptionalField(e_maxBitRate))
    strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  if (HasOptionalField(e_collapsing))
    strm << setw(indent+13) << "collapsing = " << setprecision(indent) << m_collapsing << '\n';
  if (HasOptionalField(e_nonCollapsing))
    strm << setw(indent+16) << "nonCollapsing = " << setprecision(indent) << m_nonCollapsing << '\n';
  if (HasOptionalField(e_nonCollapsingRaw))
    strm << setw(indent+19) << "nonCollapsingRaw = " << setprecision(indent) << m_nonCollapsingRaw << '\n';
  if (HasOptionalField(e_transport))
    strm << setw(indent+12) << "transport = " << setprecision(indent) << m_transport << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_GenericCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_GenericCapability), PInvalidCast);
#endif
  const H245_GenericCapability & other = (const H245_GenericCapability &)obj;

  Comparison result;

  if ((result = m_capabilityIdentifier.Compare(other.m_capabilityIdentifier)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_collapsing.Compare(other.m_collapsing)) != EqualTo)
    return result;
  if ((result = m_nonCollapsing.Compare(other.m_nonCollapsing)) != EqualTo)
    return result;
  if ((result = m_nonCollapsingRaw.Compare(other.m_nonCollapsingRaw)) != EqualTo)
    return result;
  if ((result = m_transport.Compare(other.m_transport)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GenericCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityIdentifier.GetObjectLength();
  if (HasOptionalField(e_maxBitRate))
    length += m_maxBitRate.GetObjectLength();
  if (HasOptionalField(e_collapsing))
    length += m_collapsing.GetObjectLength();
  if (HasOptionalField(e_nonCollapsing))
    length += m_nonCollapsing.GetObjectLength();
  if (HasOptionalField(e_nonCollapsingRaw))
    length += m_nonCollapsingRaw.GetObjectLength();
  if (HasOptionalField(e_transport))
    length += m_transport.GetObjectLength();
  return length;
}


BOOL H245_GenericCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_maxBitRate) && !m_maxBitRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_collapsing) && !m_collapsing.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonCollapsing) && !m_nonCollapsing.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonCollapsingRaw) && !m_nonCollapsingRaw.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transport) && !m_transport.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_GenericCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityIdentifier.Encode(strm);
  if (HasOptionalField(e_maxBitRate))
    m_maxBitRate.Encode(strm);
  if (HasOptionalField(e_collapsing))
    m_collapsing.Encode(strm);
  if (HasOptionalField(e_nonCollapsing))
    m_nonCollapsing.Encode(strm);
  if (HasOptionalField(e_nonCollapsingRaw))
    m_nonCollapsingRaw.Encode(strm);
  if (HasOptionalField(e_transport))
    m_transport.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_GenericCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GenericCapability::Class()), PInvalidCast);
#endif
  return new H245_GenericCapability(*this);
}


//
// GenericParameter
//

H245_GenericParameter::H245_GenericParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_GenericParameter::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "parameterIdentifier = " << setprecision(indent) << m_parameterIdentifier << '\n';
  strm << setw(indent+17) << "parameterValue = " << setprecision(indent) << m_parameterValue << '\n';
  if (HasOptionalField(e_supersedes))
    strm << setw(indent+13) << "supersedes = " << setprecision(indent) << m_supersedes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_GenericParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_GenericParameter), PInvalidCast);
#endif
  const H245_GenericParameter & other = (const H245_GenericParameter &)obj;

  Comparison result;

  if ((result = m_parameterIdentifier.Compare(other.m_parameterIdentifier)) != EqualTo)
    return result;
  if ((result = m_parameterValue.Compare(other.m_parameterValue)) != EqualTo)
    return result;
  if ((result = m_supersedes.Compare(other.m_supersedes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GenericParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_parameterIdentifier.GetObjectLength();
  length += m_parameterValue.GetObjectLength();
  if (HasOptionalField(e_supersedes))
    length += m_supersedes.GetObjectLength();
  return length;
}


BOOL H245_GenericParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_parameterIdentifier.Decode(strm))
    return FALSE;
  if (!m_parameterValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_supersedes) && !m_supersedes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_GenericParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_parameterIdentifier.Encode(strm);
  m_parameterValue.Encode(strm);
  if (HasOptionalField(e_supersedes))
    m_supersedes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_GenericParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GenericParameter::Class()), PInvalidCast);
#endif
  return new H245_GenericParameter(*this);
}


//
// MultiplexedStreamCapability
//

H245_MultiplexedStreamCapability::H245_MultiplexedStreamCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_capabilityOnMuxStream.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexedStreamCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "multiplexFormat = " << setprecision(indent) << m_multiplexFormat << '\n';
  strm << setw(indent+21) << "controlOnMuxStream = " << setprecision(indent) << m_controlOnMuxStream << '\n';
  if (HasOptionalField(e_capabilityOnMuxStream))
    strm << setw(indent+24) << "capabilityOnMuxStream = " << setprecision(indent) << m_capabilityOnMuxStream << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexedStreamCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexedStreamCapability), PInvalidCast);
#endif
  const H245_MultiplexedStreamCapability & other = (const H245_MultiplexedStreamCapability &)obj;

  Comparison result;

  if ((result = m_multiplexFormat.Compare(other.m_multiplexFormat)) != EqualTo)
    return result;
  if ((result = m_controlOnMuxStream.Compare(other.m_controlOnMuxStream)) != EqualTo)
    return result;
  if ((result = m_capabilityOnMuxStream.Compare(other.m_capabilityOnMuxStream)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexedStreamCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexFormat.GetObjectLength();
  length += m_controlOnMuxStream.GetObjectLength();
  if (HasOptionalField(e_capabilityOnMuxStream))
    length += m_capabilityOnMuxStream.GetObjectLength();
  return length;
}


BOOL H245_MultiplexedStreamCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexFormat.Decode(strm))
    return FALSE;
  if (!m_controlOnMuxStream.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capabilityOnMuxStream) && !m_capabilityOnMuxStream.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexedStreamCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexFormat.Encode(strm);
  m_controlOnMuxStream.Encode(strm);
  if (HasOptionalField(e_capabilityOnMuxStream))
    m_capabilityOnMuxStream.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexedStreamCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexedStreamCapability::Class()), PInvalidCast);
#endif
  return new H245_MultiplexedStreamCapability(*this);
}


//
// MultiplePayloadStreamCapability
//

H245_MultiplePayloadStreamCapability::H245_MultiplePayloadStreamCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_capabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MultiplePayloadStreamCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "capabilities = " << setprecision(indent) << m_capabilities << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplePayloadStreamCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplePayloadStreamCapability), PInvalidCast);
#endif
  const H245_MultiplePayloadStreamCapability & other = (const H245_MultiplePayloadStreamCapability &)obj;

  Comparison result;

  if ((result = m_capabilities.Compare(other.m_capabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplePayloadStreamCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilities.GetObjectLength();
  return length;
}


BOOL H245_MultiplePayloadStreamCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilities.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplePayloadStreamCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplePayloadStreamCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplePayloadStreamCapability::Class()), PInvalidCast);
#endif
  return new H245_MultiplePayloadStreamCapability(*this);
}


//
// FECCapability
//

H245_FECCapability::H245_FECCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FECCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "protectedCapability = " << setprecision(indent) << m_protectedCapability << '\n';
  if (HasOptionalField(e_fecScheme))
    strm << setw(indent+12) << "fecScheme = " << setprecision(indent) << m_fecScheme << '\n';
  if (HasOptionalField(e_rfc2733Format))
    strm << setw(indent+16) << "rfc2733Format = " << setprecision(indent) << m_rfc2733Format << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FECCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FECCapability), PInvalidCast);
#endif
  const H245_FECCapability & other = (const H245_FECCapability &)obj;

  Comparison result;

  if ((result = m_protectedCapability.Compare(other.m_protectedCapability)) != EqualTo)
    return result;
  if ((result = m_fecScheme.Compare(other.m_fecScheme)) != EqualTo)
    return result;
  if ((result = m_rfc2733Format.Compare(other.m_rfc2733Format)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FECCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedCapability.GetObjectLength();
  if (HasOptionalField(e_fecScheme))
    length += m_fecScheme.GetObjectLength();
  if (HasOptionalField(e_rfc2733Format))
    length += m_rfc2733Format.GetObjectLength();
  return length;
}


BOOL H245_FECCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_fecScheme) && !m_fecScheme.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rfc2733Format) && !m_rfc2733Format.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FECCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedCapability.Encode(strm);
  if (HasOptionalField(e_fecScheme))
    m_fecScheme.Encode(strm);
  if (HasOptionalField(e_rfc2733Format))
    m_rfc2733Format.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FECCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECCapability::Class()), PInvalidCast);
#endif
  return new H245_FECCapability(*this);
}


//
// NetworkAccessParameters
//

H245_NetworkAccessParameters::H245_NetworkAccessParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_externalReference.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_NetworkAccessParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_distribution))
    strm << setw(indent+15) << "distribution = " << setprecision(indent) << m_distribution << '\n';
  strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  strm << setw(indent+22) << "associateConference = " << setprecision(indent) << m_associateConference << '\n';
  if (HasOptionalField(e_externalReference))
    strm << setw(indent+20) << "externalReference = " << setprecision(indent) << m_externalReference << '\n';
  if (HasOptionalField(e_t120SetupProcedure))
    strm << setw(indent+21) << "t120SetupProcedure = " << setprecision(indent) << m_t120SetupProcedure << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NetworkAccessParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NetworkAccessParameters), PInvalidCast);
#endif
  const H245_NetworkAccessParameters & other = (const H245_NetworkAccessParameters &)obj;

  Comparison result;

  if ((result = m_distribution.Compare(other.m_distribution)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_associateConference.Compare(other.m_associateConference)) != EqualTo)
    return result;
  if ((result = m_externalReference.Compare(other.m_externalReference)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NetworkAccessParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_distribution))
    length += m_distribution.GetObjectLength();
  length += m_networkAddress.GetObjectLength();
  length += m_associateConference.GetObjectLength();
  if (HasOptionalField(e_externalReference))
    length += m_externalReference.GetObjectLength();
  return length;
}


BOOL H245_NetworkAccessParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_distribution) && !m_distribution.Decode(strm))
    return FALSE;
  if (!m_networkAddress.Decode(strm))
    return FALSE;
  if (!m_associateConference.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_externalReference) && !m_externalReference.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_t120SetupProcedure, m_t120SetupProcedure))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NetworkAccessParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_distribution))
    m_distribution.Encode(strm);
  m_networkAddress.Encode(strm);
  m_associateConference.Encode(strm);
  if (HasOptionalField(e_externalReference))
    m_externalReference.Encode(strm);
  KnownExtensionEncode(strm, e_t120SetupProcedure, m_t120SetupProcedure);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NetworkAccessParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters(*this);
}


//
// Q2931Address
//

H245_Q2931Address::H245_Q2931Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_subaddress.SetConstraints(PASN_Object::FixedConstraint, 1, 20);
}


#ifndef PASN_NOPRINTON
void H245_Q2931Address::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "address = " << setprecision(indent) << m_address << '\n';
  if (HasOptionalField(e_subaddress))
    strm << setw(indent+13) << "subaddress = " << setprecision(indent) << m_subaddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_Q2931Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_Q2931Address), PInvalidCast);
#endif
  const H245_Q2931Address & other = (const H245_Q2931Address &)obj;

  Comparison result;

  if ((result = m_address.Compare(other.m_address)) != EqualTo)
    return result;
  if ((result = m_subaddress.Compare(other.m_subaddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Q2931Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_address.GetObjectLength();
  if (HasOptionalField(e_subaddress))
    length += m_subaddress.GetObjectLength();
  return length;
}


BOOL H245_Q2931Address::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_address.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subaddress) && !m_subaddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_Q2931Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_address.Encode(strm);
  if (HasOptionalField(e_subaddress))
    m_subaddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_Q2931Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Q2931Address::Class()), PInvalidCast);
#endif
  return new H245_Q2931Address(*this);
}


//
// H223LogicalChannelParameters
//

H245_H223LogicalChannelParameters::H245_H223LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "adaptationLayerType = " << setprecision(indent) << m_adaptationLayerType << '\n';
  strm << setw(indent+18) << "segmentableFlag = " << setprecision(indent) << m_segmentableFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223LogicalChannelParameters), PInvalidCast);
#endif
  const H245_H223LogicalChannelParameters & other = (const H245_H223LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_adaptationLayerType.Compare(other.m_adaptationLayerType)) != EqualTo)
    return result;
  if ((result = m_segmentableFlag.Compare(other.m_segmentableFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223LogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_adaptationLayerType.GetObjectLength();
  length += m_segmentableFlag.GetObjectLength();
  return length;
}


BOOL H245_H223LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_adaptationLayerType.Decode(strm))
    return FALSE;
  if (!m_segmentableFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters(*this);
}


//
// H223AL1MParameters
//

H245_H223AL1MParameters::H245_H223AL1MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_rcpcCodeRate.SetConstraints(PASN_Object::FixedConstraint, 8, 32);
  m_rsCodeCorrection.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_H223AL1MParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "transferMode = " << setprecision(indent) << m_transferMode << '\n';
  strm << setw(indent+12) << "headerFEC = " << setprecision(indent) << m_headerFEC << '\n';
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+15) << "rcpcCodeRate = " << setprecision(indent) << m_rcpcCodeRate << '\n';
  strm << setw(indent+10) << "arqType = " << setprecision(indent) << m_arqType << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent+17) << "alsduSplitting = " << setprecision(indent) << m_alsduSplitting << '\n';
  if (HasOptionalField(e_rsCodeCorrection))
    strm << setw(indent+19) << "rsCodeCorrection = " << setprecision(indent) << m_rsCodeCorrection << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223AL1MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223AL1MParameters), PInvalidCast);
#endif
  const H245_H223AL1MParameters & other = (const H245_H223AL1MParameters &)obj;

  Comparison result;

  if ((result = m_transferMode.Compare(other.m_transferMode)) != EqualTo)
    return result;
  if ((result = m_headerFEC.Compare(other.m_headerFEC)) != EqualTo)
    return result;
  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_rcpcCodeRate.Compare(other.m_rcpcCodeRate)) != EqualTo)
    return result;
  if ((result = m_arqType.Compare(other.m_arqType)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;
  if ((result = m_alsduSplitting.Compare(other.m_alsduSplitting)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL1MParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transferMode.GetObjectLength();
  length += m_headerFEC.GetObjectLength();
  length += m_crcLength.GetObjectLength();
  length += m_rcpcCodeRate.GetObjectLength();
  length += m_arqType.GetObjectLength();
  length += m_alpduInterleaving.GetObjectLength();
  length += m_alsduSplitting.GetObjectLength();
  return length;
}


BOOL H245_H223AL1MParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transferMode.Decode(strm))
    return FALSE;
  if (!m_headerFEC.Decode(strm))
    return FALSE;
  if (!m_crcLength.Decode(strm))
    return FALSE;
  if (!m_rcpcCodeRate.Decode(strm))
    return FALSE;
  if (!m_arqType.Decode(strm))
    return FALSE;
  if (!m_alpduInterleaving.Decode(strm))
    return FALSE;
  if (!m_alsduSplitting.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rsCodeCorrection, m_rsCodeCorrection))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223AL1MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transferMode.Encode(strm);
  m_headerFEC.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_alsduSplitting.Encode(strm);
  KnownExtensionEncode(strm, e_rsCodeCorrection, m_rsCodeCorrection);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223AL1MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters(*this);
}


//
// H223AL2MParameters
//

H245_H223AL2MParameters::H245_H223AL2MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223AL2MParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "headerFEC = " << setprecision(indent) << m_headerFEC << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223AL2MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223AL2MParameters), PInvalidCast);
#endif
  const H245_H223AL2MParameters & other = (const H245_H223AL2MParameters &)obj;

  Comparison result;

  if ((result = m_headerFEC.Compare(other.m_headerFEC)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL2MParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_headerFEC.GetObjectLength();
  length += m_alpduInterleaving.GetObjectLength();
  return length;
}


BOOL H245_H223AL2MParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_headerFEC.Decode(strm))
    return FALSE;
  if (!m_alpduInterleaving.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223AL2MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_headerFEC.Encode(strm);
  m_alpduInterleaving.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223AL2MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL2MParameters(*this);
}


//
// H223AL3MParameters
//

H245_H223AL3MParameters::H245_H223AL3MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_rcpcCodeRate.SetConstraints(PASN_Object::FixedConstraint, 8, 32);
  m_rsCodeCorrection.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_H223AL3MParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "headerFormat = " << setprecision(indent) << m_headerFormat << '\n';
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+15) << "rcpcCodeRate = " << setprecision(indent) << m_rcpcCodeRate << '\n';
  strm << setw(indent+10) << "arqType = " << setprecision(indent) << m_arqType << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  if (HasOptionalField(e_rsCodeCorrection))
    strm << setw(indent+19) << "rsCodeCorrection = " << setprecision(indent) << m_rsCodeCorrection << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223AL3MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223AL3MParameters), PInvalidCast);
#endif
  const H245_H223AL3MParameters & other = (const H245_H223AL3MParameters &)obj;

  Comparison result;

  if ((result = m_headerFormat.Compare(other.m_headerFormat)) != EqualTo)
    return result;
  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_rcpcCodeRate.Compare(other.m_rcpcCodeRate)) != EqualTo)
    return result;
  if ((result = m_arqType.Compare(other.m_arqType)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL3MParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_headerFormat.GetObjectLength();
  length += m_crcLength.GetObjectLength();
  length += m_rcpcCodeRate.GetObjectLength();
  length += m_arqType.GetObjectLength();
  length += m_alpduInterleaving.GetObjectLength();
  return length;
}


BOOL H245_H223AL3MParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_headerFormat.Decode(strm))
    return FALSE;
  if (!m_crcLength.Decode(strm))
    return FALSE;
  if (!m_rcpcCodeRate.Decode(strm))
    return FALSE;
  if (!m_arqType.Decode(strm))
    return FALSE;
  if (!m_alpduInterleaving.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rsCodeCorrection, m_rsCodeCorrection))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223AL3MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_headerFormat.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  KnownExtensionEncode(strm, e_rsCodeCorrection, m_rsCodeCorrection);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223AL3MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters(*this);
}


//
// H223AnnexCArqParameters
//

H245_H223AnnexCArqParameters::H245_H223AnnexCArqParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223AnnexCArqParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "numberOfRetransmissions = " << setprecision(indent) << m_numberOfRetransmissions << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223AnnexCArqParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223AnnexCArqParameters), PInvalidCast);
#endif
  const H245_H223AnnexCArqParameters & other = (const H245_H223AnnexCArqParameters &)obj;

  Comparison result;

  if ((result = m_numberOfRetransmissions.Compare(other.m_numberOfRetransmissions)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AnnexCArqParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numberOfRetransmissions.GetObjectLength();
  length += m_sendBufferSize.GetObjectLength();
  return length;
}


BOOL H245_H223AnnexCArqParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numberOfRetransmissions.Decode(strm))
    return FALSE;
  if (!m_sendBufferSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223AnnexCArqParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfRetransmissions.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223AnnexCArqParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCArqParameters(*this);
}


//
// V76HDLCParameters
//

H245_V76HDLCParameters::H245_V76HDLCParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_n401.SetConstraints(PASN_Object::FixedConstraint, 1, 4095);
}


#ifndef PASN_NOPRINTON
void H245_V76HDLCParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+7) << "n401 = " << setprecision(indent) << m_n401 << '\n';
  strm << setw(indent+24) << "loopbackTestProcedure = " << setprecision(indent) << m_loopbackTestProcedure << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V76HDLCParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V76HDLCParameters), PInvalidCast);
#endif
  const H245_V76HDLCParameters & other = (const H245_V76HDLCParameters &)obj;

  Comparison result;

  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_n401.Compare(other.m_n401)) != EqualTo)
    return result;
  if ((result = m_loopbackTestProcedure.Compare(other.m_loopbackTestProcedure)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76HDLCParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_crcLength.GetObjectLength();
  length += m_n401.GetObjectLength();
  length += m_loopbackTestProcedure.GetObjectLength();
  return length;
}


BOOL H245_V76HDLCParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_crcLength.Decode(strm))
    return FALSE;
  if (!m_n401.Decode(strm))
    return FALSE;
  if (!m_loopbackTestProcedure.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V76HDLCParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_crcLength.Encode(strm);
  m_n401.Encode(strm);
  m_loopbackTestProcedure.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V76HDLCParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76HDLCParameters::Class()), PInvalidCast);
#endif
  return new H245_V76HDLCParameters(*this);
}


//
// RTPPayloadType
//

H245_RTPPayloadType::H245_RTPPayloadType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_payloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_RTPPayloadType::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "payloadDescriptor = " << setprecision(indent) << m_payloadDescriptor << '\n';
  if (HasOptionalField(e_payloadType))
    strm << setw(indent+14) << "payloadType = " << setprecision(indent) << m_payloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RTPPayloadType::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RTPPayloadType), PInvalidCast);
#endif
  const H245_RTPPayloadType & other = (const H245_RTPPayloadType &)obj;

  Comparison result;

  if ((result = m_payloadDescriptor.Compare(other.m_payloadDescriptor)) != EqualTo)
    return result;
  if ((result = m_payloadType.Compare(other.m_payloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPPayloadType::GetDataLength() const
{
  PINDEX length = 0;
  length += m_payloadDescriptor.GetObjectLength();
  if (HasOptionalField(e_payloadType))
    length += m_payloadType.GetObjectLength();
  return length;
}


BOOL H245_RTPPayloadType::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_payloadDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_payloadType) && !m_payloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RTPPayloadType::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_payloadDescriptor.Encode(strm);
  if (HasOptionalField(e_payloadType))
    m_payloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RTPPayloadType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPPayloadType::Class()), PInvalidCast);
#endif
  return new H245_RTPPayloadType(*this);
}


//
// MultiplePayloadStream
//

H245_MultiplePayloadStream::H245_MultiplePayloadStream(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplePayloadStream::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "elements = " << setprecision(indent) << m_elements << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplePayloadStream::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplePayloadStream), PInvalidCast);
#endif
  const H245_MultiplePayloadStream & other = (const H245_MultiplePayloadStream &)obj;

  Comparison result;

  if ((result = m_elements.Compare(other.m_elements)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplePayloadStream::GetDataLength() const
{
  PINDEX length = 0;
  length += m_elements.GetObjectLength();
  return length;
}


BOOL H245_MultiplePayloadStream::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_elements.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplePayloadStream::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_elements.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplePayloadStream::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplePayloadStream::Class()), PInvalidCast);
#endif
  return new H245_MultiplePayloadStream(*this);
}


//
// EncryptionSync
//

H245_EncryptionSync::H245_EncryptionSync(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_synchFlag.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_h235Key.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_escrowentry.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_EncryptionSync::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "synchFlag = " << setprecision(indent) << m_synchFlag << '\n';
  strm << setw(indent+10) << "h235Key = " << setprecision(indent) << m_h235Key << '\n';
  if (HasOptionalField(e_escrowentry))
    strm << setw(indent+14) << "escrowentry = " << setprecision(indent) << m_escrowentry << '\n';
  if (HasOptionalField(e_genericParameter))
    strm << setw(indent+19) << "genericParameter = " << setprecision(indent) << m_genericParameter << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EncryptionSync::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EncryptionSync), PInvalidCast);
#endif
  const H245_EncryptionSync & other = (const H245_EncryptionSync &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_synchFlag.Compare(other.m_synchFlag)) != EqualTo)
    return result;
  if ((result = m_h235Key.Compare(other.m_h235Key)) != EqualTo)
    return result;
  if ((result = m_escrowentry.Compare(other.m_escrowentry)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionSync::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  length += m_synchFlag.GetObjectLength();
  length += m_h235Key.GetObjectLength();
  if (HasOptionalField(e_escrowentry))
    length += m_escrowentry.GetObjectLength();
  return length;
}


BOOL H245_EncryptionSync::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!m_synchFlag.Decode(strm))
    return FALSE;
  if (!m_h235Key.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_escrowentry) && !m_escrowentry.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericParameter, m_genericParameter))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EncryptionSync::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_synchFlag.Encode(strm);
  m_h235Key.Encode(strm);
  if (HasOptionalField(e_escrowentry))
    m_escrowentry.Encode(strm);
  KnownExtensionEncode(strm, e_genericParameter, m_genericParameter);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EncryptionSync::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionSync::Class()), PInvalidCast);
#endif
  return new H245_EncryptionSync(*this);
}


//
// OpenLogicalChannelReject
//

H245_OpenLogicalChannelReject::H245_OpenLogicalChannelReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannelReject), PInvalidCast);
#endif
  const H245_OpenLogicalChannelReject & other = (const H245_OpenLogicalChannelReject &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannelReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannelReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannelReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelReject::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelReject(*this);
}


//
// OpenLogicalChannelConfirm
//

H245_OpenLogicalChannelConfirm::H245_OpenLogicalChannelConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelConfirm::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannelConfirm), PInvalidCast);
#endif
  const H245_OpenLogicalChannelConfirm & other = (const H245_OpenLogicalChannelConfirm &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannelConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannelConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannelConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelConfirm(*this);
}


//
// H2250LogicalChannelAckParameters
//

H245_H2250LogicalChannelAckParameters::H245_H2250LogicalChannelAckParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 2)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
  IncludeOptionalField(e_flowControlToZero);
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_H2250LogicalChannelAckParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_sessionID))
    strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_dynamicRTPPayloadType))
    strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  if (HasOptionalField(e_flowControlToZero))
    strm << setw(indent+20) << "flowControlToZero = " << setprecision(indent) << m_flowControlToZero << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250LogicalChannelAckParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250LogicalChannelAckParameters), PInvalidCast);
#endif
  const H245_H2250LogicalChannelAckParameters & other = (const H245_H2250LogicalChannelAckParameters &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250LogicalChannelAckParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  if (HasOptionalField(e_sessionID))
    length += m_sessionID.GetObjectLength();
  if (HasOptionalField(e_mediaChannel))
    length += m_mediaChannel.GetObjectLength();
  if (HasOptionalField(e_mediaControlChannel))
    length += m_mediaControlChannel.GetObjectLength();
  if (HasOptionalField(e_dynamicRTPPayloadType))
    length += m_dynamicRTPPayloadType.GetObjectLength();
  return length;
}


BOOL H245_H2250LogicalChannelAckParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sessionID) && !m_sessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaChannel) && !m_mediaChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaControlChannel) && !m_mediaControlChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_dynamicRTPPayloadType) && !m_dynamicRTPPayloadType.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_flowControlToZero, m_flowControlToZero))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_portNumber, m_portNumber))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250LogicalChannelAckParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_sessionID))
    m_sessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
  KnownExtensionEncode(strm, e_flowControlToZero, m_flowControlToZero);
  KnownExtensionEncode(strm, e_portNumber, m_portNumber);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250LogicalChannelAckParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelAckParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelAckParameters(*this);
}


//
// CloseLogicalChannel
//

H245_CloseLogicalChannel::H245_CloseLogicalChannel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  IncludeOptionalField(e_reason);
}


#ifndef PASN_NOPRINTON
void H245_CloseLogicalChannel::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+9) << "source = " << setprecision(indent) << m_source << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CloseLogicalChannel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CloseLogicalChannel), PInvalidCast);
#endif
  const H245_CloseLogicalChannel & other = (const H245_CloseLogicalChannel &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_source.Compare(other.m_source)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CloseLogicalChannel::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  length += m_source.GetObjectLength();
  return length;
}


BOOL H245_CloseLogicalChannel::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_source.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_reason, m_reason))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CloseLogicalChannel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_source.Encode(strm);
  KnownExtensionEncode(strm, e_reason, m_reason);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CloseLogicalChannel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel(*this);
}


//
// RequestChannelClose
//

H245_RequestChannelClose::H245_RequestChannelClose(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
  IncludeOptionalField(e_reason);
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelClose::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  if (HasOptionalField(e_qosCapability))
    strm << setw(indent+16) << "qosCapability = " << setprecision(indent) << m_qosCapability << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestChannelClose::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestChannelClose), PInvalidCast);
#endif
  const H245_RequestChannelClose & other = (const H245_RequestChannelClose &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelClose::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_RequestChannelClose::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_qosCapability, m_qosCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_reason, m_reason))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestChannelClose::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  KnownExtensionEncode(strm, e_qosCapability, m_qosCapability);
  KnownExtensionEncode(strm, e_reason, m_reason);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestChannelClose::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelClose::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelClose(*this);
}


//
// RequestChannelCloseReject
//

H245_RequestChannelCloseReject::H245_RequestChannelCloseReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestChannelCloseReject), PInvalidCast);
#endif
  const H245_RequestChannelCloseReject & other = (const H245_RequestChannelCloseReject &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_RequestChannelCloseReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestChannelCloseReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestChannelCloseReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseReject::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseReject(*this);
}


//
// MultiplexEntrySend
//

H245_MultiplexEntrySend::H245_MultiplexEntrySend(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexEntryDescriptors.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySend::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+28) << "multiplexEntryDescriptors = " << setprecision(indent) << m_multiplexEntryDescriptors << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySend::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntrySend), PInvalidCast);
#endif
  const H245_MultiplexEntrySend & other = (const H245_MultiplexEntrySend &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexEntryDescriptors.Compare(other.m_multiplexEntryDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySend::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_multiplexEntryDescriptors.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntrySend::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_multiplexEntryDescriptors.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntrySend::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_multiplexEntryDescriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntrySend::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySend::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySend(*this);
}


//
// MultiplexEntryDescriptor
//

H245_MultiplexEntryDescriptor::H245_MultiplexEntryDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_elementList.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntryDescriptor::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  if (HasOptionalField(e_elementList))
    strm << setw(indent+14) << "elementList = " << setprecision(indent) << m_elementList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntryDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntryDescriptor), PInvalidCast);
#endif
  const H245_MultiplexEntryDescriptor & other = (const H245_MultiplexEntryDescriptor &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_elementList.Compare(other.m_elementList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntryDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexTableEntryNumber.GetObjectLength();
  if (HasOptionalField(e_elementList))
    length += m_elementList.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntryDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexTableEntryNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_elementList) && !m_elementList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntryDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_elementList))
    m_elementList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntryDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryDescriptor::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryDescriptor(*this);
}


//
// MultiplexElement
//

H245_MultiplexElement::H245_MultiplexElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexElement::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent+14) << "repeatCount = " << setprecision(indent) << m_repeatCount << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexElement), PInvalidCast);
#endif
  const H245_MultiplexElement & other = (const H245_MultiplexElement &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_repeatCount.Compare(other.m_repeatCount)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  length += m_repeatCount.GetObjectLength();
  return length;
}


BOOL H245_MultiplexElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;
  if (!m_repeatCount.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  m_repeatCount.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement(*this);
}


//
// MultiplexEntrySendAck
//

H245_MultiplexEntrySendAck::H245_MultiplexEntrySendAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexTableEntryNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntrySendAck), PInvalidCast);
#endif
  const H245_MultiplexEntrySendAck & other = (const H245_MultiplexEntrySendAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_multiplexTableEntryNumber.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntrySendAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_multiplexTableEntryNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntrySendAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_multiplexTableEntryNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntrySendAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendAck::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendAck(*this);
}


//
// MultiplexEntrySendReject
//

H245_MultiplexEntrySendReject::H245_MultiplexEntrySendReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rejectionDescriptions.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+24) << "rejectionDescriptions = " << setprecision(indent) << m_rejectionDescriptions << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntrySendReject), PInvalidCast);
#endif
  const H245_MultiplexEntrySendReject & other = (const H245_MultiplexEntrySendReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_rejectionDescriptions.Compare(other.m_rejectionDescriptions)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_rejectionDescriptions.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntrySendReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_rejectionDescriptions.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntrySendReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_rejectionDescriptions.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntrySendReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendReject::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendReject(*this);
}


//
// MultiplexEntryRejectionDescriptions
//

H245_MultiplexEntryRejectionDescriptions::H245_MultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntryRejectionDescriptions::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntryRejectionDescriptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntryRejectionDescriptions), PInvalidCast);
#endif
  const H245_MultiplexEntryRejectionDescriptions & other = (const H245_MultiplexEntryRejectionDescriptions &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntryRejectionDescriptions::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexTableEntryNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntryRejectionDescriptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexTableEntryNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntryRejectionDescriptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryRejectionDescriptions(*this);
}


//
// MultiplexEntrySendRelease
//

H245_MultiplexEntrySendRelease::H245_MultiplexEntrySendRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexTableEntryNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendRelease::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexEntrySendRelease), PInvalidCast);
#endif
  const H245_MultiplexEntrySendRelease & other = (const H245_MultiplexEntrySendRelease &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendRelease::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexTableEntryNumber.GetObjectLength();
  return length;
}


BOOL H245_MultiplexEntrySendRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexTableEntryNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexEntrySendRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexEntrySendRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendRelease::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendRelease(*this);
}


//
// RequestMultiplexEntry
//

H245_RequestMultiplexEntry::H245_RequestMultiplexEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntry::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMultiplexEntry), PInvalidCast);
#endif
  const H245_RequestMultiplexEntry & other = (const H245_RequestMultiplexEntry &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntry::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entryNumbers.GetObjectLength();
  return length;
}


BOOL H245_RequestMultiplexEntry::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entryNumbers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMultiplexEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMultiplexEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntry::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntry(*this);
}


//
// RequestMultiplexEntryAck
//

H245_RequestMultiplexEntryAck::H245_RequestMultiplexEntryAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMultiplexEntryAck), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryAck & other = (const H245_RequestMultiplexEntryAck &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entryNumbers.GetObjectLength();
  return length;
}


BOOL H245_RequestMultiplexEntryAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entryNumbers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMultiplexEntryAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMultiplexEntryAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryAck::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryAck(*this);
}


//
// RequestMultiplexEntryReject
//

H245_RequestMultiplexEntryReject::H245_RequestMultiplexEntryReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
  m_rejectionDescriptions.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent+24) << "rejectionDescriptions = " << setprecision(indent) << m_rejectionDescriptions << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMultiplexEntryReject), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryReject & other = (const H245_RequestMultiplexEntryReject &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;
  if ((result = m_rejectionDescriptions.Compare(other.m_rejectionDescriptions)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entryNumbers.GetObjectLength();
  length += m_rejectionDescriptions.GetObjectLength();
  return length;
}


BOOL H245_RequestMultiplexEntryReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entryNumbers.Decode(strm))
    return FALSE;
  if (!m_rejectionDescriptions.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMultiplexEntryReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);
  m_rejectionDescriptions.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMultiplexEntryReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryReject::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryReject(*this);
}


//
// RequestMultiplexEntryRejectionDescriptions
//

H245_RequestMultiplexEntryRejectionDescriptions::H245_RequestMultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryRejectionDescriptions::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryRejectionDescriptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMultiplexEntryRejectionDescriptions), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryRejectionDescriptions & other = (const H245_RequestMultiplexEntryRejectionDescriptions &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryRejectionDescriptions::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexTableEntryNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_RequestMultiplexEntryRejectionDescriptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexTableEntryNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMultiplexEntryRejectionDescriptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRejectionDescriptions(*this);
}


//
// RequestMultiplexEntryRelease
//

H245_RequestMultiplexEntryRelease::H245_RequestMultiplexEntryRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryRelease::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMultiplexEntryRelease), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryRelease & other = (const H245_RequestMultiplexEntryRelease &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryRelease::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entryNumbers.GetObjectLength();
  return length;
}


BOOL H245_RequestMultiplexEntryRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entryNumbers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMultiplexEntryRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMultiplexEntryRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRelease(*this);
}


//
// RequestMode
//

H245_RequestMode::H245_RequestMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_requestedModes.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RequestMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+17) << "requestedModes = " << setprecision(indent) << m_requestedModes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestMode), PInvalidCast);
#endif
  const H245_RequestMode & other = (const H245_RequestMode &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_requestedModes.Compare(other.m_requestedModes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_requestedModes.GetObjectLength();
  return length;
}


BOOL H245_RequestMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_requestedModes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_requestedModes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMode::Class()), PInvalidCast);
#endif
  return new H245_RequestMode(*this);
}


//
// RequestModeAck
//

H245_RequestModeAck::H245_RequestModeAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+11) << "response = " << setprecision(indent) << m_response << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestModeAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestModeAck), PInvalidCast);
#endif
  const H245_RequestModeAck & other = (const H245_RequestModeAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_response.Compare(other.m_response)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestModeAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_response.GetObjectLength();
  return length;
}


BOOL H245_RequestModeAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_response.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestModeAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_response.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestModeAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeAck::Class()), PInvalidCast);
#endif
  return new H245_RequestModeAck(*this);
}


//
// RequestModeReject
//

H245_RequestModeReject::H245_RequestModeReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestModeReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestModeReject), PInvalidCast);
#endif
  const H245_RequestModeReject & other = (const H245_RequestModeReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestModeReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_RequestModeReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestModeReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestModeReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeReject::Class()), PInvalidCast);
#endif
  return new H245_RequestModeReject(*this);
}


//
// RedundancyEncodingDTModeElement
//

H245_RedundancyEncodingDTModeElement::H245_RedundancyEncodingDTModeElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingDTModeElement::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingDTModeElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncodingDTModeElement), PInvalidCast);
#endif
  const H245_RedundancyEncodingDTModeElement & other = (const H245_RedundancyEncodingDTModeElement &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingDTModeElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncodingDTModeElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncodingDTModeElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncodingDTModeElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingDTModeElement::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingDTModeElement(*this);
}


//
// MultiplePayloadStreamMode
//

H245_MultiplePayloadStreamMode::H245_MultiplePayloadStreamMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplePayloadStreamMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "elements = " << setprecision(indent) << m_elements << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplePayloadStreamMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplePayloadStreamMode), PInvalidCast);
#endif
  const H245_MultiplePayloadStreamMode & other = (const H245_MultiplePayloadStreamMode &)obj;

  Comparison result;

  if ((result = m_elements.Compare(other.m_elements)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplePayloadStreamMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_elements.GetObjectLength();
  return length;
}


BOOL H245_MultiplePayloadStreamMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_elements.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplePayloadStreamMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_elements.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplePayloadStreamMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplePayloadStreamMode::Class()), PInvalidCast);
#endif
  return new H245_MultiplePayloadStreamMode(*this);
}


//
// FECMode
//

H245_FECMode::H245_FECMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FECMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "protectedElement = " << setprecision(indent) << m_protectedElement << '\n';
  if (HasOptionalField(e_fecScheme))
    strm << setw(indent+12) << "fecScheme = " << setprecision(indent) << m_fecScheme << '\n';
  if (HasOptionalField(e_rfc2733Format))
    strm << setw(indent+16) << "rfc2733Format = " << setprecision(indent) << m_rfc2733Format << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FECMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FECMode), PInvalidCast);
#endif
  const H245_FECMode & other = (const H245_FECMode &)obj;

  Comparison result;

  if ((result = m_protectedElement.Compare(other.m_protectedElement)) != EqualTo)
    return result;
  if ((result = m_fecScheme.Compare(other.m_fecScheme)) != EqualTo)
    return result;
  if ((result = m_rfc2733Format.Compare(other.m_rfc2733Format)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FECMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedElement.GetObjectLength();
  if (HasOptionalField(e_fecScheme))
    length += m_fecScheme.GetObjectLength();
  if (HasOptionalField(e_rfc2733Format))
    length += m_rfc2733Format.GetObjectLength();
  return length;
}


BOOL H245_FECMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedElement.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_fecScheme) && !m_fecScheme.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rfc2733Format) && !m_rfc2733Format.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FECMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedElement.Encode(strm);
  if (HasOptionalField(e_fecScheme))
    m_fecScheme.Encode(strm);
  if (HasOptionalField(e_rfc2733Format))
    m_rfc2733Format.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FECMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECMode::Class()), PInvalidCast);
#endif
  return new H245_FECMode(*this);
}


//
// H223ModeParameters
//

H245_H223ModeParameters::H245_H223ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223ModeParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "adaptationLayerType = " << setprecision(indent) << m_adaptationLayerType << '\n';
  strm << setw(indent+18) << "segmentableFlag = " << setprecision(indent) << m_segmentableFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223ModeParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223ModeParameters), PInvalidCast);
#endif
  const H245_H223ModeParameters & other = (const H245_H223ModeParameters &)obj;

  Comparison result;

  if ((result = m_adaptationLayerType.Compare(other.m_adaptationLayerType)) != EqualTo)
    return result;
  if ((result = m_segmentableFlag.Compare(other.m_segmentableFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223ModeParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_adaptationLayerType.GetObjectLength();
  length += m_segmentableFlag.GetObjectLength();
  return length;
}


BOOL H245_H223ModeParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_adaptationLayerType.Decode(strm))
    return FALSE;
  if (!m_segmentableFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223ModeParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters(*this);
}


//
// RedundancyEncodingMode
//

H245_RedundancyEncodingMode::H245_RedundancyEncodingMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncodingMode), PInvalidCast);
#endif
  const H245_RedundancyEncodingMode & other = (const H245_RedundancyEncodingMode &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redundancyEncodingMethod.GetObjectLength();
  if (HasOptionalField(e_secondaryEncoding))
    length += m_secondaryEncoding.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncodingMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_redundancyEncodingMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_secondaryEncoding) && !m_secondaryEncoding.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncodingMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncodingMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMode::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMode(*this);
}


//
// H261VideoMode
//

H245_H261VideoMode::H245_H261VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
}


#ifndef PASN_NOPRINTON
void H245_H261VideoMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resolution = " << setprecision(indent) << m_resolution << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+25) << "stillImageTransmission = " << setprecision(indent) << m_stillImageTransmission << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H261VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H261VideoMode), PInvalidCast);
#endif
  const H245_H261VideoMode & other = (const H245_H261VideoMode &)obj;

  Comparison result;

  if ((result = m_resolution.Compare(other.m_resolution)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_stillImageTransmission.Compare(other.m_stillImageTransmission)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H261VideoMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_resolution.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  length += m_stillImageTransmission.GetObjectLength();
  return length;
}


BOOL H245_H261VideoMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_resolution.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_stillImageTransmission.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H261VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H261VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H261VideoMode(*this);
}


//
// H262VideoMode
//

H245_H262VideoMode::H245_H262VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_framesPerSecond.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_H262VideoMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "profileAndLevel = " << setprecision(indent) << m_profileAndLevel << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_framesPerSecond))
    strm << setw(indent+18) << "framesPerSecond = " << setprecision(indent) << m_framesPerSecond << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H262VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H262VideoMode), PInvalidCast);
#endif
  const H245_H262VideoMode & other = (const H245_H262VideoMode &)obj;

  Comparison result;

  if ((result = m_profileAndLevel.Compare(other.m_profileAndLevel)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_framesPerSecond.Compare(other.m_framesPerSecond)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H262VideoMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_profileAndLevel.GetObjectLength();
  if (HasOptionalField(e_videoBitRate))
    length += m_videoBitRate.GetObjectLength();
  if (HasOptionalField(e_vbvBufferSize))
    length += m_vbvBufferSize.GetObjectLength();
  if (HasOptionalField(e_samplesPerLine))
    length += m_samplesPerLine.GetObjectLength();
  if (HasOptionalField(e_linesPerFrame))
    length += m_linesPerFrame.GetObjectLength();
  if (HasOptionalField(e_framesPerSecond))
    length += m_framesPerSecond.GetObjectLength();
  if (HasOptionalField(e_luminanceSampleRate))
    length += m_luminanceSampleRate.GetObjectLength();
  return length;
}


BOOL H245_H262VideoMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_profileAndLevel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_videoBitRate) && !m_videoBitRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_vbvBufferSize) && !m_vbvBufferSize.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_samplesPerLine) && !m_samplesPerLine.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_linesPerFrame) && !m_linesPerFrame.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_framesPerSecond) && !m_framesPerSecond.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_luminanceSampleRate) && !m_luminanceSampleRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H262VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_profileAndLevel.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H262VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H262VideoMode(*this);
}


//
// IS11172AudioMode
//

H245_IS11172AudioMode::H245_IS11172AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 448);
}


#ifndef PASN_NOPRINTON
void H245_IS11172AudioMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "audioLayer = " << setprecision(indent) << m_audioLayer << '\n';
  strm << setw(indent+16) << "audioSampling = " << setprecision(indent) << m_audioSampling << '\n';
  strm << setw(indent+19) << "multichannelType = " << setprecision(indent) << m_multichannelType << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS11172AudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS11172AudioMode), PInvalidCast);
#endif
  const H245_IS11172AudioMode & other = (const H245_IS11172AudioMode &)obj;

  Comparison result;

  if ((result = m_audioLayer.Compare(other.m_audioLayer)) != EqualTo)
    return result;
  if ((result = m_audioSampling.Compare(other.m_audioSampling)) != EqualTo)
    return result;
  if ((result = m_multichannelType.Compare(other.m_multichannelType)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172AudioMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioLayer.GetObjectLength();
  length += m_audioSampling.GetObjectLength();
  length += m_multichannelType.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  return length;
}


BOOL H245_IS11172AudioMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioLayer.Decode(strm))
    return FALSE;
  if (!m_audioSampling.Decode(strm))
    return FALSE;
  if (!m_multichannelType.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS11172AudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS11172AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode(*this);
}


//
// IS13818AudioMode
//

H245_IS13818AudioMode::H245_IS13818AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 1130);
}


#ifndef PASN_NOPRINTON
void H245_IS13818AudioMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "audioLayer = " << setprecision(indent) << m_audioLayer << '\n';
  strm << setw(indent+16) << "audioSampling = " << setprecision(indent) << m_audioSampling << '\n';
  strm << setw(indent+19) << "multichannelType = " << setprecision(indent) << m_multichannelType << '\n';
  strm << setw(indent+26) << "lowFrequencyEnhancement = " << setprecision(indent) << m_lowFrequencyEnhancement << '\n';
  strm << setw(indent+15) << "multilingual = " << setprecision(indent) << m_multilingual << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS13818AudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS13818AudioMode), PInvalidCast);
#endif
  const H245_IS13818AudioMode & other = (const H245_IS13818AudioMode &)obj;

  Comparison result;

  if ((result = m_audioLayer.Compare(other.m_audioLayer)) != EqualTo)
    return result;
  if ((result = m_audioSampling.Compare(other.m_audioSampling)) != EqualTo)
    return result;
  if ((result = m_multichannelType.Compare(other.m_multichannelType)) != EqualTo)
    return result;
  if ((result = m_lowFrequencyEnhancement.Compare(other.m_lowFrequencyEnhancement)) != EqualTo)
    return result;
  if ((result = m_multilingual.Compare(other.m_multilingual)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS13818AudioMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioLayer.GetObjectLength();
  length += m_audioSampling.GetObjectLength();
  length += m_multichannelType.GetObjectLength();
  length += m_lowFrequencyEnhancement.GetObjectLength();
  length += m_multilingual.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  return length;
}


BOOL H245_IS13818AudioMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioLayer.Decode(strm))
    return FALSE;
  if (!m_audioSampling.Decode(strm))
    return FALSE;
  if (!m_multichannelType.Decode(strm))
    return FALSE;
  if (!m_lowFrequencyEnhancement.Decode(strm))
    return FALSE;
  if (!m_multilingual.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS13818AudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS13818AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode(*this);
}


//
// G7231AnnexCMode
//

H245_G7231AnnexCMode::H245_G7231AnnexCMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  strm << setw(indent+22) << "g723AnnexCAudioMode = " << setprecision(indent) << m_g723AnnexCAudioMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_G7231AnnexCMode), PInvalidCast);
#endif
  const H245_G7231AnnexCMode & other = (const H245_G7231AnnexCMode &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_g723AnnexCAudioMode.Compare(other.m_g723AnnexCAudioMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxAl_sduAudioFrames.GetObjectLength();
  length += m_silenceSuppression.GetObjectLength();
  length += m_g723AnnexCAudioMode.GetObjectLength();
  return length;
}


BOOL H245_G7231AnnexCMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxAl_sduAudioFrames.Decode(strm))
    return FALSE;
  if (!m_silenceSuppression.Decode(strm))
    return FALSE;
  if (!m_g723AnnexCAudioMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_G7231AnnexCMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  m_g723AnnexCAudioMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_G7231AnnexCMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCMode(*this);
}


//
// DataMode
//

H245_DataMode::H245_DataMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_DataMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "application = " << setprecision(indent) << m_application << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataMode), PInvalidCast);
#endif
  const H245_DataMode & other = (const H245_DataMode &)obj;

  Comparison result;

  if ((result = m_application.Compare(other.m_application)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_application.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  return length;
}


BOOL H245_DataMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_application.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_application.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode::Class()), PInvalidCast);
#endif
  return new H245_DataMode(*this);
}


//
// MaintenanceLoopRequest
//

H245_MaintenanceLoopRequest::H245_MaintenanceLoopRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopRequest::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MaintenanceLoopRequest), PInvalidCast);
#endif
  const H245_MaintenanceLoopRequest & other = (const H245_MaintenanceLoopRequest &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_MaintenanceLoopRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MaintenanceLoopRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MaintenanceLoopRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopRequest::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopRequest(*this);
}


//
// MaintenanceLoopAck
//

H245_MaintenanceLoopAck::H245_MaintenanceLoopAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MaintenanceLoopAck), PInvalidCast);
#endif
  const H245_MaintenanceLoopAck & other = (const H245_MaintenanceLoopAck &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_MaintenanceLoopAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MaintenanceLoopAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MaintenanceLoopAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopAck::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopAck(*this);
}


//
// MaintenanceLoopReject
//

H245_MaintenanceLoopReject::H245_MaintenanceLoopReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MaintenanceLoopReject), PInvalidCast);
#endif
  const H245_MaintenanceLoopReject & other = (const H245_MaintenanceLoopReject &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  length += m_cause.GetObjectLength();
  return length;
}


BOOL H245_MaintenanceLoopReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;
  if (!m_cause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MaintenanceLoopReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MaintenanceLoopReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject(*this);
}


//
// CommunicationModeCommand
//

H245_CommunicationModeCommand::H245_CommunicationModeCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_communicationModeTable.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "communicationModeTable = " << setprecision(indent) << m_communicationModeTable << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CommunicationModeCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CommunicationModeCommand), PInvalidCast);
#endif
  const H245_CommunicationModeCommand & other = (const H245_CommunicationModeCommand &)obj;

  Comparison result;

  if ((result = m_communicationModeTable.Compare(other.m_communicationModeTable)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CommunicationModeCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_communicationModeTable.GetObjectLength();
  return length;
}


BOOL H245_CommunicationModeCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_communicationModeTable.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CommunicationModeCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_communicationModeTable.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CommunicationModeCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeCommand::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeCommand(*this);
}


//
// TerminalLabel
//

H245_TerminalLabel::H245_TerminalLabel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalLabel::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "mcuNumber = " << setprecision(indent) << m_mcuNumber << '\n';
  strm << setw(indent+17) << "terminalNumber = " << setprecision(indent) << m_terminalNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalLabel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalLabel), PInvalidCast);
#endif
  const H245_TerminalLabel & other = (const H245_TerminalLabel &)obj;

  Comparison result;

  if ((result = m_mcuNumber.Compare(other.m_mcuNumber)) != EqualTo)
    return result;
  if ((result = m_terminalNumber.Compare(other.m_terminalNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalLabel::GetDataLength() const
{
  PINDEX length = 0;
  length += m_mcuNumber.GetObjectLength();
  length += m_terminalNumber.GetObjectLength();
  return length;
}


BOOL H245_TerminalLabel::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_mcuNumber.Decode(strm))
    return FALSE;
  if (!m_terminalNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalLabel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mcuNumber.Encode(strm);
  m_terminalNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalLabel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return new H245_TerminalLabel(*this);
}


//
// RequestAllTerminalIDsResponse
//

H245_RequestAllTerminalIDsResponse::H245_RequestAllTerminalIDsResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestAllTerminalIDsResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "terminalInformation = " << setprecision(indent) << m_terminalInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestAllTerminalIDsResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestAllTerminalIDsResponse), PInvalidCast);
#endif
  const H245_RequestAllTerminalIDsResponse & other = (const H245_RequestAllTerminalIDsResponse &)obj;

  Comparison result;

  if ((result = m_terminalInformation.Compare(other.m_terminalInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestAllTerminalIDsResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalInformation.GetObjectLength();
  return length;
}


BOOL H245_RequestAllTerminalIDsResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalInformation.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestAllTerminalIDsResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestAllTerminalIDsResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestAllTerminalIDsResponse::Class()), PInvalidCast);
#endif
  return new H245_RequestAllTerminalIDsResponse(*this);
}


//
// TerminalInformation
//

H245_TerminalInformation::H245_TerminalInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalInformation::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalInformation), PInvalidCast);
#endif
  const H245_TerminalInformation & other = (const H245_TerminalInformation &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_terminalID.GetObjectLength();
  return length;
}


BOOL H245_TerminalInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_terminalID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalInformation::Class()), PInvalidCast);
#endif
  return new H245_TerminalInformation(*this);
}


//
// DialingInformationNumber
//

H245_DialingInformationNumber::H245_DialingInformationNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_networkAddress.SetConstraints(PASN_Object::FixedConstraint, 0, 40);
  m_subAddress.SetConstraints(PASN_Object::FixedConstraint, 1, 40);
  m_networkType.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_DialingInformationNumber::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_subAddress))
    strm << setw(indent+13) << "subAddress = " << setprecision(indent) << m_subAddress << '\n';
  strm << setw(indent+14) << "networkType = " << setprecision(indent) << m_networkType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DialingInformationNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DialingInformationNumber), PInvalidCast);
#endif
  const H245_DialingInformationNumber & other = (const H245_DialingInformationNumber &)obj;

  Comparison result;

  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_subAddress.Compare(other.m_subAddress)) != EqualTo)
    return result;
  if ((result = m_networkType.Compare(other.m_networkType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DialingInformationNumber::GetDataLength() const
{
  PINDEX length = 0;
  length += m_networkAddress.GetObjectLength();
  if (HasOptionalField(e_subAddress))
    length += m_subAddress.GetObjectLength();
  length += m_networkType.GetObjectLength();
  return length;
}


BOOL H245_DialingInformationNumber::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_networkAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subAddress) && !m_subAddress.Decode(strm))
    return FALSE;
  if (!m_networkType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DialingInformationNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_networkAddress.Encode(strm);
  if (HasOptionalField(e_subAddress))
    m_subAddress.Encode(strm);
  m_networkType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DialingInformationNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DialingInformationNumber::Class()), PInvalidCast);
#endif
  return new H245_DialingInformationNumber(*this);
}


//
// LogicalChannelRateReject
//

H245_LogicalChannelRateReject::H245_LogicalChannelRateReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_LogicalChannelRateReject::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_currentMaximumBitRate))
    strm << setw(indent+24) << "currentMaximumBitRate = " << setprecision(indent) << m_currentMaximumBitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_LogicalChannelRateReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_LogicalChannelRateReject), PInvalidCast);
#endif
  const H245_LogicalChannelRateReject & other = (const H245_LogicalChannelRateReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_currentMaximumBitRate.Compare(other.m_currentMaximumBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_LogicalChannelRateReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_logicalChannelNumber.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_currentMaximumBitRate))
    length += m_currentMaximumBitRate.GetObjectLength();
  return length;
}


BOOL H245_LogicalChannelRateReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_currentMaximumBitRate) && !m_currentMaximumBitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_LogicalChannelRateReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_logicalChannelNumber.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_currentMaximumBitRate))
    m_currentMaximumBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_LogicalChannelRateReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelRateReject::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelRateReject(*this);
}


//
// FlowControlCommand
//

H245_FlowControlCommand::H245_FlowControlCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FlowControlCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "scope = " << setprecision(indent) << m_scope << '\n';
  strm << setw(indent+14) << "restriction = " << setprecision(indent) << m_restriction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FlowControlCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FlowControlCommand), PInvalidCast);
#endif
  const H245_FlowControlCommand & other = (const H245_FlowControlCommand &)obj;

  Comparison result;

  if ((result = m_scope.Compare(other.m_scope)) != EqualTo)
    return result;
  if ((result = m_restriction.Compare(other.m_restriction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FlowControlCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_scope.GetObjectLength();
  length += m_restriction.GetObjectLength();
  return length;
}


BOOL H245_FlowControlCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_scope.Decode(strm))
    return FALSE;
  if (!m_restriction.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FlowControlCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_scope.Encode(strm);
  m_restriction.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FlowControlCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand(*this);
}


//
// MiscellaneousCommand
//

H245_MiscellaneousCommand::H245_MiscellaneousCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  if (HasOptionalField(e_direction))
    strm << setw(indent+12) << "direction = " << setprecision(indent) << m_direction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand), PInvalidCast);
#endif
  const H245_MiscellaneousCommand & other = (const H245_MiscellaneousCommand &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber.GetObjectLength();
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_type.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_direction, m_direction))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);
  KnownExtensionEncode(strm, e_direction, m_direction);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand(*this);
}


//
// MobileMultilinkReconfigurationCommand
//

H245_MobileMultilinkReconfigurationCommand::H245_MobileMultilinkReconfigurationCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_sampleSize.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_samplesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_MobileMultilinkReconfigurationCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "sampleSize = " << setprecision(indent) << m_sampleSize << '\n';
  strm << setw(indent+18) << "samplesPerFrame = " << setprecision(indent) << m_samplesPerFrame << '\n';
  strm << setw(indent+9) << "status = " << setprecision(indent) << m_status << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MobileMultilinkReconfigurationCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MobileMultilinkReconfigurationCommand), PInvalidCast);
#endif
  const H245_MobileMultilinkReconfigurationCommand & other = (const H245_MobileMultilinkReconfigurationCommand &)obj;

  Comparison result;

  if ((result = m_sampleSize.Compare(other.m_sampleSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerFrame.Compare(other.m_samplesPerFrame)) != EqualTo)
    return result;
  if ((result = m_status.Compare(other.m_status)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MobileMultilinkReconfigurationCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sampleSize.GetObjectLength();
  length += m_samplesPerFrame.GetObjectLength();
  length += m_status.GetObjectLength();
  return length;
}


BOOL H245_MobileMultilinkReconfigurationCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sampleSize.Decode(strm))
    return FALSE;
  if (!m_samplesPerFrame.Decode(strm))
    return FALSE;
  if (!m_status.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MobileMultilinkReconfigurationCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sampleSize.Encode(strm);
  m_samplesPerFrame.Encode(strm);
  m_status.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MobileMultilinkReconfigurationCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MobileMultilinkReconfigurationCommand::Class()), PInvalidCast);
#endif
  return new H245_MobileMultilinkReconfigurationCommand(*this);
}


//
// FunctionNotSupported
//

H245_FunctionNotSupported::H245_FunctionNotSupported(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FunctionNotSupported::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  if (HasOptionalField(e_returnedFunction))
    strm << setw(indent+19) << "returnedFunction = " << setprecision(indent) << m_returnedFunction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FunctionNotSupported::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FunctionNotSupported), PInvalidCast);
#endif
  const H245_FunctionNotSupported & other = (const H245_FunctionNotSupported &)obj;

  Comparison result;

  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;
  if ((result = m_returnedFunction.Compare(other.m_returnedFunction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FunctionNotSupported::GetDataLength() const
{
  PINDEX length = 0;
  length += m_cause.GetObjectLength();
  if (HasOptionalField(e_returnedFunction))
    length += m_returnedFunction.GetObjectLength();
  return length;
}


BOOL H245_FunctionNotSupported::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_cause.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_returnedFunction) && !m_returnedFunction.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FunctionNotSupported::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_cause.Encode(strm);
  if (HasOptionalField(e_returnedFunction))
    m_returnedFunction.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FunctionNotSupported::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotSupported::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotSupported(*this);
}


//
// MiscellaneousIndication
//

H245_MiscellaneousIndication::H245_MiscellaneousIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousIndication::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousIndication), PInvalidCast);
#endif
  const H245_MiscellaneousIndication & other = (const H245_MiscellaneousIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber.GetObjectLength();
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication(*this);
}


//
// JitterIndication
//

H245_JitterIndication::H245_JitterIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_estimatedReceivedJitterMantissa.SetConstraints(PASN_Object::FixedConstraint, 0, 3);
  m_estimatedReceivedJitterExponent.SetConstraints(PASN_Object::FixedConstraint, 0, 7);
  m_skippedFrameCount.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_additionalDecoderBuffer.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
}


#ifndef PASN_NOPRINTON
void H245_JitterIndication::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "scope = " << setprecision(indent) << m_scope << '\n';
  strm << setw(indent+34) << "estimatedReceivedJitterMantissa = " << setprecision(indent) << m_estimatedReceivedJitterMantissa << '\n';
  strm << setw(indent+34) << "estimatedReceivedJitterExponent = " << setprecision(indent) << m_estimatedReceivedJitterExponent << '\n';
  if (HasOptionalField(e_skippedFrameCount))
    strm << setw(indent+20) << "skippedFrameCount = " << setprecision(indent) << m_skippedFrameCount << '\n';
  if (HasOptionalField(e_additionalDecoderBuffer))
    strm << setw(indent+26) << "additionalDecoderBuffer = " << setprecision(indent) << m_additionalDecoderBuffer << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_JitterIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_JitterIndication), PInvalidCast);
#endif
  const H245_JitterIndication & other = (const H245_JitterIndication &)obj;

  Comparison result;

  if ((result = m_scope.Compare(other.m_scope)) != EqualTo)
    return result;
  if ((result = m_estimatedReceivedJitterMantissa.Compare(other.m_estimatedReceivedJitterMantissa)) != EqualTo)
    return result;
  if ((result = m_estimatedReceivedJitterExponent.Compare(other.m_estimatedReceivedJitterExponent)) != EqualTo)
    return result;
  if ((result = m_skippedFrameCount.Compare(other.m_skippedFrameCount)) != EqualTo)
    return result;
  if ((result = m_additionalDecoderBuffer.Compare(other.m_additionalDecoderBuffer)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_JitterIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_scope.GetObjectLength();
  length += m_estimatedReceivedJitterMantissa.GetObjectLength();
  length += m_estimatedReceivedJitterExponent.GetObjectLength();
  if (HasOptionalField(e_skippedFrameCount))
    length += m_skippedFrameCount.GetObjectLength();
  if (HasOptionalField(e_additionalDecoderBuffer))
    length += m_additionalDecoderBuffer.GetObjectLength();
  return length;
}


BOOL H245_JitterIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_scope.Decode(strm))
    return FALSE;
  if (!m_estimatedReceivedJitterMantissa.Decode(strm))
    return FALSE;
  if (!m_estimatedReceivedJitterExponent.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_skippedFrameCount) && !m_skippedFrameCount.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_additionalDecoderBuffer) && !m_additionalDecoderBuffer.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_JitterIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_scope.Encode(strm);
  m_estimatedReceivedJitterMantissa.Encode(strm);
  m_estimatedReceivedJitterExponent.Encode(strm);
  if (HasOptionalField(e_skippedFrameCount))
    m_skippedFrameCount.Encode(strm);
  if (HasOptionalField(e_additionalDecoderBuffer))
    m_additionalDecoderBuffer.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_JitterIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_JitterIndication::Class()), PInvalidCast);
#endif
  return new H245_JitterIndication(*this);
}


//
// FlowControlIndication
//

H245_FlowControlIndication::H245_FlowControlIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FlowControlIndication::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "scope = " << setprecision(indent) << m_scope << '\n';
  strm << setw(indent+14) << "restriction = " << setprecision(indent) << m_restriction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FlowControlIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FlowControlIndication), PInvalidCast);
#endif
  const H245_FlowControlIndication & other = (const H245_FlowControlIndication &)obj;

  Comparison result;

  if ((result = m_scope.Compare(other.m_scope)) != EqualTo)
    return result;
  if ((result = m_restriction.Compare(other.m_restriction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FlowControlIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_scope.GetObjectLength();
  length += m_restriction.GetObjectLength();
  return length;
}


BOOL H245_FlowControlIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_scope.Decode(strm))
    return FALSE;
  if (!m_restriction.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FlowControlIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_scope.Encode(strm);
  m_restriction.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FlowControlIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlIndication::Class()), PInvalidCast);
#endif
  return new H245_FlowControlIndication(*this);
}


//
// VCCapability_availableBitRates
//

H245_VCCapability_availableBitRates::H245_VCCapability_availableBitRates(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_availableBitRates::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability_availableBitRates::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability_availableBitRates), PInvalidCast);
#endif
  const H245_VCCapability_availableBitRates & other = (const H245_VCCapability_availableBitRates &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_availableBitRates::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_VCCapability_availableBitRates::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability_availableBitRates::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability_availableBitRates::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates(*this);
}


//
// VCCapability_aal1ViaGateway
//

H245_VCCapability_aal1ViaGateway::H245_VCCapability_aal1ViaGateway(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_gatewayAddress.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal1ViaGateway::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "gatewayAddress = " << setprecision(indent) << m_gatewayAddress << '\n';
  strm << setw(indent+20) << "nullClockRecovery = " << setprecision(indent) << m_nullClockRecovery << '\n';
  strm << setw(indent+20) << "srtsClockRecovery = " << setprecision(indent) << m_srtsClockRecovery << '\n';
  strm << setw(indent+24) << "adaptiveClockRecovery = " << setprecision(indent) << m_adaptiveClockRecovery << '\n';
  strm << setw(indent+22) << "nullErrorCorrection = " << setprecision(indent) << m_nullErrorCorrection << '\n';
  strm << setw(indent+18) << "longInterleaver = " << setprecision(indent) << m_longInterleaver << '\n';
  strm << setw(indent+19) << "shortInterleaver = " << setprecision(indent) << m_shortInterleaver << '\n';
  strm << setw(indent+22) << "errorCorrectionOnly = " << setprecision(indent) << m_errorCorrectionOnly << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal1ViaGateway::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability_aal1ViaGateway), PInvalidCast);
#endif
  const H245_VCCapability_aal1ViaGateway & other = (const H245_VCCapability_aal1ViaGateway &)obj;

  Comparison result;

  if ((result = m_gatewayAddress.Compare(other.m_gatewayAddress)) != EqualTo)
    return result;
  if ((result = m_nullClockRecovery.Compare(other.m_nullClockRecovery)) != EqualTo)
    return result;
  if ((result = m_srtsClockRecovery.Compare(other.m_srtsClockRecovery)) != EqualTo)
    return result;
  if ((result = m_adaptiveClockRecovery.Compare(other.m_adaptiveClockRecovery)) != EqualTo)
    return result;
  if ((result = m_nullErrorCorrection.Compare(other.m_nullErrorCorrection)) != EqualTo)
    return result;
  if ((result = m_longInterleaver.Compare(other.m_longInterleaver)) != EqualTo)
    return result;
  if ((result = m_shortInterleaver.Compare(other.m_shortInterleaver)) != EqualTo)
    return result;
  if ((result = m_errorCorrectionOnly.Compare(other.m_errorCorrectionOnly)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal1ViaGateway::GetDataLength() const
{
  PINDEX length = 0;
  length += m_gatewayAddress.GetObjectLength();
  length += m_nullClockRecovery.GetObjectLength();
  length += m_srtsClockRecovery.GetObjectLength();
  length += m_adaptiveClockRecovery.GetObjectLength();
  length += m_nullErrorCorrection.GetObjectLength();
  length += m_longInterleaver.GetObjectLength();
  length += m_shortInterleaver.GetObjectLength();
  length += m_errorCorrectionOnly.GetObjectLength();
  length += m_structuredDataTransfer.GetObjectLength();
  length += m_partiallyFilledCells.GetObjectLength();
  return length;
}


BOOL H245_VCCapability_aal1ViaGateway::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_gatewayAddress.Decode(strm))
    return FALSE;
  if (!m_nullClockRecovery.Decode(strm))
    return FALSE;
  if (!m_srtsClockRecovery.Decode(strm))
    return FALSE;
  if (!m_adaptiveClockRecovery.Decode(strm))
    return FALSE;
  if (!m_nullErrorCorrection.Decode(strm))
    return FALSE;
  if (!m_longInterleaver.Decode(strm))
    return FALSE;
  if (!m_shortInterleaver.Decode(strm))
    return FALSE;
  if (!m_errorCorrectionOnly.Decode(strm))
    return FALSE;
  if (!m_structuredDataTransfer.Decode(strm))
    return FALSE;
  if (!m_partiallyFilledCells.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability_aal1ViaGateway::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_gatewayAddress.Encode(strm);
  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability_aal1ViaGateway::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal1ViaGateway::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal1ViaGateway(*this);
}


//
// RefPictureSelection_enhancedReferencePicSelect
//

H245_RefPictureSelection_enhancedReferencePicSelect::H245_RefPictureSelection_enhancedReferencePicSelect(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection_enhancedReferencePicSelect::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_subPictureRemovalParameters))
    strm << setw(indent+30) << "subPictureRemovalParameters = " << setprecision(indent) << m_subPictureRemovalParameters << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection_enhancedReferencePicSelect::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RefPictureSelection_enhancedReferencePicSelect), PInvalidCast);
#endif
  const H245_RefPictureSelection_enhancedReferencePicSelect & other = (const H245_RefPictureSelection_enhancedReferencePicSelect &)obj;

  Comparison result;

  if ((result = m_subPictureRemovalParameters.Compare(other.m_subPictureRemovalParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection_enhancedReferencePicSelect::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_subPictureRemovalParameters))
    length += m_subPictureRemovalParameters.GetObjectLength();
  return length;
}


BOOL H245_RefPictureSelection_enhancedReferencePicSelect::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_subPictureRemovalParameters) && !m_subPictureRemovalParameters.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RefPictureSelection_enhancedReferencePicSelect::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_subPictureRemovalParameters))
    m_subPictureRemovalParameters.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RefPictureSelection_enhancedReferencePicSelect::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_enhancedReferencePicSelect::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_enhancedReferencePicSelect(*this);
}


//
// CustomPictureFormat_mPI
//

H245_CustomPictureFormat_mPI::H245_CustomPictureFormat_mPI(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_standardMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 31);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_mPI::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_standardMPI))
    strm << setw(indent+14) << "standardMPI = " << setprecision(indent) << m_standardMPI << '\n';
  if (HasOptionalField(e_customPCF))
    strm << setw(indent+12) << "customPCF = " << setprecision(indent) << m_customPCF << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_mPI::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CustomPictureFormat_mPI), PInvalidCast);
#endif
  const H245_CustomPictureFormat_mPI & other = (const H245_CustomPictureFormat_mPI &)obj;

  Comparison result;

  if ((result = m_standardMPI.Compare(other.m_standardMPI)) != EqualTo)
    return result;
  if ((result = m_customPCF.Compare(other.m_customPCF)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_mPI::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_standardMPI))
    length += m_standardMPI.GetObjectLength();
  if (HasOptionalField(e_customPCF))
    length += m_customPCF.GetObjectLength();
  return length;
}


BOOL H245_CustomPictureFormat_mPI::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_standardMPI) && !m_standardMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_customPCF) && !m_customPCF.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CustomPictureFormat_mPI::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_standardMPI))
    m_standardMPI.Encode(strm);
  if (HasOptionalField(e_customPCF))
    m_customPCF.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CustomPictureFormat_mPI::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI(*this);
}


//
// DepFECCapability_rfc2733
//

H245_DepFECCapability_rfc2733::H245_DepFECCapability_rfc2733(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DepFECCapability_rfc2733::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "redundancyEncoding = " << setprecision(indent) << m_redundancyEncoding << '\n';
  strm << setw(indent+17) << "separateStream = " << setprecision(indent) << m_separateStream << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECCapability_rfc2733::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECCapability_rfc2733), PInvalidCast);
#endif
  const H245_DepFECCapability_rfc2733 & other = (const H245_DepFECCapability_rfc2733 &)obj;

  Comparison result;

  if ((result = m_redundancyEncoding.Compare(other.m_redundancyEncoding)) != EqualTo)
    return result;
  if ((result = m_separateStream.Compare(other.m_separateStream)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECCapability_rfc2733::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redundancyEncoding.GetObjectLength();
  length += m_separateStream.GetObjectLength();
  return length;
}


BOOL H245_DepFECCapability_rfc2733::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_redundancyEncoding.Decode(strm))
    return FALSE;
  if (!m_separateStream.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECCapability_rfc2733::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncoding.Encode(strm);
  m_separateStream.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECCapability_rfc2733::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECCapability_rfc2733::Class()), PInvalidCast);
#endif
  return new H245_DepFECCapability_rfc2733(*this);
}


//
// OpenLogicalChannel_forwardLogicalChannelParameters
//

H245_OpenLogicalChannel_forwardLogicalChannelParameters::H245_OpenLogicalChannel_forwardLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel_forwardLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_forwardLogicalChannelDependency))
    strm << setw(indent+34) << "forwardLogicalChannelDependency = " << setprecision(indent) << m_forwardLogicalChannelDependency << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel_forwardLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannel_forwardLogicalChannelParameters), PInvalidCast);
#endif
  const H245_OpenLogicalChannel_forwardLogicalChannelParameters & other = (const H245_OpenLogicalChannel_forwardLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;
  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel_forwardLogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_portNumber))
    length += m_portNumber.GetObjectLength();
  length += m_dataType.GetObjectLength();
  length += m_multiplexParameters.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannel_forwardLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_portNumber) && !m_portNumber.Decode(strm))
    return FALSE;
  if (!m_dataType.Decode(strm))
    return FALSE;
  if (!m_multiplexParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_forwardLogicalChannelDependency, m_forwardLogicalChannelDependency))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_replacementFor, m_replacementFor))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannel_forwardLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  m_dataType.Encode(strm);
  m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_forwardLogicalChannelDependency, m_forwardLogicalChannelDependency);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannel_forwardLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_forwardLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_forwardLogicalChannelParameters(*this);
}


//
// OpenLogicalChannel_reverseLogicalChannelParameters
//

H245_OpenLogicalChannel_reverseLogicalChannelParameters::H245_OpenLogicalChannel_reverseLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel_reverseLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_multiplexParameters))
    strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_reverseLogicalChannelDependency))
    strm << setw(indent+34) << "reverseLogicalChannelDependency = " << setprecision(indent) << m_reverseLogicalChannelDependency << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel_reverseLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannel_reverseLogicalChannelParameters), PInvalidCast);
#endif
  const H245_OpenLogicalChannel_reverseLogicalChannelParameters & other = (const H245_OpenLogicalChannel_reverseLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel_reverseLogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dataType.GetObjectLength();
  if (HasOptionalField(e_multiplexParameters))
    length += m_multiplexParameters.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannel_reverseLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dataType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_multiplexParameters) && !m_multiplexParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_reverseLogicalChannelDependency, m_reverseLogicalChannelDependency))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_replacementFor, m_replacementFor))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannel_reverseLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dataType.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_reverseLogicalChannelDependency, m_reverseLogicalChannelDependency);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannel_reverseLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_reverseLogicalChannelParameters(*this);
}


//
// RedundancyEncoding_rtpRedundancyEncoding
//

H245_RedundancyEncoding_rtpRedundancyEncoding::H245_RedundancyEncoding_rtpRedundancyEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncoding_rtpRedundancyEncoding::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_primary))
    strm << setw(indent+10) << "primary = " << setprecision(indent) << m_primary << '\n';
  if (HasOptionalField(e_secondary))
    strm << setw(indent+12) << "secondary = " << setprecision(indent) << m_secondary << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncoding_rtpRedundancyEncoding::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncoding_rtpRedundancyEncoding), PInvalidCast);
#endif
  const H245_RedundancyEncoding_rtpRedundancyEncoding & other = (const H245_RedundancyEncoding_rtpRedundancyEncoding &)obj;

  Comparison result;

  if ((result = m_primary.Compare(other.m_primary)) != EqualTo)
    return result;
  if ((result = m_secondary.Compare(other.m_secondary)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncoding_rtpRedundancyEncoding::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_primary))
    length += m_primary.GetObjectLength();
  if (HasOptionalField(e_secondary))
    length += m_secondary.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncoding_rtpRedundancyEncoding::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_primary) && !m_primary.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_secondary) && !m_secondary.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncoding_rtpRedundancyEncoding::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_primary))
    m_primary.Encode(strm);
  if (HasOptionalField(e_secondary))
    m_secondary.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncoding_rtpRedundancyEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncoding_rtpRedundancyEncoding::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncoding_rtpRedundancyEncoding(*this);
}


//
// DepFECData_rfc2733
//

H245_DepFECData_rfc2733::H245_DepFECData_rfc2733(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DepFECData_rfc2733::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "mode = " << setprecision(indent) << m_mode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECData_rfc2733::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECData_rfc2733), PInvalidCast);
#endif
  const H245_DepFECData_rfc2733 & other = (const H245_DepFECData_rfc2733 &)obj;

  Comparison result;

  if ((result = m_mode.Compare(other.m_mode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECData_rfc2733::GetDataLength() const
{
  PINDEX length = 0;
  length += m_mode.GetObjectLength();
  return length;
}


BOOL H245_DepFECData_rfc2733::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_mode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECData_rfc2733::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECData_rfc2733::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData_rfc2733::Class()), PInvalidCast);
#endif
  return new H245_DepFECData_rfc2733(*this);
}


//
// FECData_rfc2733
//

H245_FECData_rfc2733::H245_FECData_rfc2733(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_protectedPayloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_FECData_rfc2733::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "protectedPayloadType = " << setprecision(indent) << m_protectedPayloadType << '\n';
  if (HasOptionalField(e_fecScheme))
    strm << setw(indent+12) << "fecScheme = " << setprecision(indent) << m_fecScheme << '\n';
  strm << setw(indent+10) << "pktMode = " << setprecision(indent) << m_pktMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_FECData_rfc2733::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_FECData_rfc2733), PInvalidCast);
#endif
  const H245_FECData_rfc2733 & other = (const H245_FECData_rfc2733 &)obj;

  Comparison result;

  if ((result = m_protectedPayloadType.Compare(other.m_protectedPayloadType)) != EqualTo)
    return result;
  if ((result = m_fecScheme.Compare(other.m_fecScheme)) != EqualTo)
    return result;
  if ((result = m_pktMode.Compare(other.m_pktMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FECData_rfc2733::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protectedPayloadType.GetObjectLength();
  if (HasOptionalField(e_fecScheme))
    length += m_fecScheme.GetObjectLength();
  length += m_pktMode.GetObjectLength();
  return length;
}


BOOL H245_FECData_rfc2733::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protectedPayloadType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_fecScheme) && !m_fecScheme.Decode(strm))
    return FALSE;
  if (!m_pktMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_FECData_rfc2733::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protectedPayloadType.Encode(strm);
  if (HasOptionalField(e_fecScheme))
    m_fecScheme.Encode(strm);
  m_pktMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_FECData_rfc2733::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECData_rfc2733::Class()), PInvalidCast);
#endif
  return new H245_FECData_rfc2733(*this);
}


//
// UnicastAddress_iPSourceRouteAddress
//

H245_UnicastAddress_iPSourceRouteAddress::H245_UnicastAddress_iPSourceRouteAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPSourceRouteAddress::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "routing = " << setprecision(indent) << m_routing << '\n';
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent+8) << "route = " << setprecision(indent) << m_route << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPSourceRouteAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UnicastAddress_iPSourceRouteAddress), PInvalidCast);
#endif
  const H245_UnicastAddress_iPSourceRouteAddress & other = (const H245_UnicastAddress_iPSourceRouteAddress &)obj;

  Comparison result;

  if ((result = m_routing.Compare(other.m_routing)) != EqualTo)
    return result;
  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;
  if ((result = m_route.Compare(other.m_route)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPSourceRouteAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_routing.GetObjectLength();
  length += m_network.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  length += m_route.GetObjectLength();
  return length;
}


BOOL H245_UnicastAddress_iPSourceRouteAddress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_routing.Decode(strm))
    return FALSE;
  if (!m_network.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;
  if (!m_route.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UnicastAddress_iPSourceRouteAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_routing.Encode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
  m_route.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UnicastAddress_iPSourceRouteAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress(*this);
}


//
// OpenLogicalChannelAck_reverseLogicalChannelParameters
//

H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::H245_OpenLogicalChannelAck_reverseLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "reverseLogicalChannelNumber = " << setprecision(indent) << m_reverseLogicalChannelNumber << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  if (HasOptionalField(e_multiplexParameters))
    strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannelAck_reverseLogicalChannelParameters), PInvalidCast);
#endif
  const H245_OpenLogicalChannelAck_reverseLogicalChannelParameters & other = (const H245_OpenLogicalChannelAck_reverseLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_reverseLogicalChannelNumber.Compare(other.m_reverseLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reverseLogicalChannelNumber.GetObjectLength();
  if (HasOptionalField(e_portNumber))
    length += m_portNumber.GetObjectLength();
  if (HasOptionalField(e_multiplexParameters))
    length += m_multiplexParameters.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reverseLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_portNumber) && !m_portNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_multiplexParameters) && !m_multiplexParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_replacementFor, m_replacementFor))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reverseLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_reverseLogicalChannelParameters(*this);
}


//
// DepFECMode_rfc2733Mode
//

H245_DepFECMode_rfc2733Mode::H245_DepFECMode_rfc2733Mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DepFECMode_rfc2733Mode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "mode = " << setprecision(indent) << m_mode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECMode_rfc2733Mode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECMode_rfc2733Mode), PInvalidCast);
#endif
  const H245_DepFECMode_rfc2733Mode & other = (const H245_DepFECMode_rfc2733Mode &)obj;

  Comparison result;

  if ((result = m_mode.Compare(other.m_mode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECMode_rfc2733Mode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_mode.GetObjectLength();
  return length;
}


BOOL H245_DepFECMode_rfc2733Mode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_mode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECMode_rfc2733Mode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECMode_rfc2733Mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode_rfc2733Mode::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode_rfc2733Mode(*this);
}


//
// ConferenceRequest_requestTerminalCertificate
//

H245_ConferenceRequest_requestTerminalCertificate::H245_ConferenceRequest_requestTerminalCertificate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_sRandom.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_ConferenceRequest_requestTerminalCertificate::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  if (HasOptionalField(e_certSelectionCriteria))
    strm << setw(indent+24) << "certSelectionCriteria = " << setprecision(indent) << m_certSelectionCriteria << '\n';
  if (HasOptionalField(e_sRandom))
    strm << setw(indent+10) << "sRandom = " << setprecision(indent) << m_sRandom << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceRequest_requestTerminalCertificate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceRequest_requestTerminalCertificate), PInvalidCast);
#endif
  const H245_ConferenceRequest_requestTerminalCertificate & other = (const H245_ConferenceRequest_requestTerminalCertificate &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_certSelectionCriteria.Compare(other.m_certSelectionCriteria)) != EqualTo)
    return result;
  if ((result = m_sRandom.Compare(other.m_sRandom)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceRequest_requestTerminalCertificate::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_terminalLabel))
    length += m_terminalLabel.GetObjectLength();
  if (HasOptionalField(e_certSelectionCriteria))
    length += m_certSelectionCriteria.GetObjectLength();
  if (HasOptionalField(e_sRandom))
    length += m_sRandom.GetObjectLength();
  return length;
}


BOOL H245_ConferenceRequest_requestTerminalCertificate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_terminalLabel) && !m_terminalLabel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_certSelectionCriteria) && !m_certSelectionCriteria.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sRandom) && !m_sRandom.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceRequest_requestTerminalCertificate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certSelectionCriteria))
    m_certSelectionCriteria.Encode(strm);
  if (HasOptionalField(e_sRandom))
    m_sRandom.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceRequest_requestTerminalCertificate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceRequest_requestTerminalCertificate::Class()), PInvalidCast);
#endif
  return new H245_ConferenceRequest_requestTerminalCertificate(*this);
}


//
// ConferenceResponse_mCTerminalIDResponse
//

H245_ConferenceResponse_mCTerminalIDResponse::H245_ConferenceResponse_mCTerminalIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_mCTerminalIDResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_mCTerminalIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_mCTerminalIDResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_mCTerminalIDResponse & other = (const H245_ConferenceResponse_mCTerminalIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_mCTerminalIDResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_terminalID.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_mCTerminalIDResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_terminalID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_mCTerminalIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_mCTerminalIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_mCTerminalIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_mCTerminalIDResponse(*this);
}


//
// ConferenceResponse_terminalIDResponse
//

H245_ConferenceResponse_terminalIDResponse::H245_ConferenceResponse_terminalIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_terminalIDResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_terminalIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_terminalIDResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_terminalIDResponse & other = (const H245_ConferenceResponse_terminalIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_terminalIDResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_terminalID.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_terminalIDResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_terminalID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_terminalIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_terminalIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_terminalIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_terminalIDResponse(*this);
}


//
// ConferenceResponse_conferenceIDResponse
//

H245_ConferenceResponse_conferenceIDResponse::H245_ConferenceResponse_conferenceIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_conferenceIDResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_conferenceIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_conferenceIDResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_conferenceIDResponse & other = (const H245_ConferenceResponse_conferenceIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_conferenceIDResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_conferenceIDResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_conferenceIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_conferenceID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_conferenceIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_conferenceIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_conferenceIDResponse(*this);
}


//
// ConferenceResponse_passwordResponse
//

H245_ConferenceResponse_passwordResponse::H245_ConferenceResponse_passwordResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_passwordResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_passwordResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_passwordResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_passwordResponse & other = (const H245_ConferenceResponse_passwordResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_passwordResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_password.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_passwordResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_password.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_passwordResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_password.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_passwordResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_passwordResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_passwordResponse(*this);
}


//
// ConferenceResponse_chairTokenOwnerResponse
//

H245_ConferenceResponse_chairTokenOwnerResponse::H245_ConferenceResponse_chairTokenOwnerResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_chairTokenOwnerResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_chairTokenOwnerResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_chairTokenOwnerResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_chairTokenOwnerResponse & other = (const H245_ConferenceResponse_chairTokenOwnerResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_chairTokenOwnerResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalLabel.GetObjectLength();
  length += m_terminalID.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_chairTokenOwnerResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_terminalID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_chairTokenOwnerResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_chairTokenOwnerResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_chairTokenOwnerResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_chairTokenOwnerResponse(*this);
}


//
// ConferenceResponse_terminalCertificateResponse
//

H245_ConferenceResponse_terminalCertificateResponse::H245_ConferenceResponse_terminalCertificateResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_certificateResponse.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_terminalCertificateResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  if (HasOptionalField(e_certificateResponse))
    strm << setw(indent+22) << "certificateResponse = " << setprecision(indent) << m_certificateResponse << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_terminalCertificateResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_terminalCertificateResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_terminalCertificateResponse & other = (const H245_ConferenceResponse_terminalCertificateResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_certificateResponse.Compare(other.m_certificateResponse)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_terminalCertificateResponse::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_terminalLabel))
    length += m_terminalLabel.GetObjectLength();
  if (HasOptionalField(e_certificateResponse))
    length += m_certificateResponse.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_terminalCertificateResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_terminalLabel) && !m_terminalLabel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_certificateResponse) && !m_certificateResponse.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_terminalCertificateResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certificateResponse))
    m_certificateResponse.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_terminalCertificateResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_terminalCertificateResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_terminalCertificateResponse(*this);
}


//
// MultilinkRequest_maximumHeaderInterval
//

H245_MultilinkRequest_maximumHeaderInterval::H245_MultilinkRequest_maximumHeaderInterval(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_maximumHeaderInterval::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "requestType = " << setprecision(indent) << m_requestType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_maximumHeaderInterval::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkRequest_maximumHeaderInterval), PInvalidCast);
#endif
  const H245_MultilinkRequest_maximumHeaderInterval & other = (const H245_MultilinkRequest_maximumHeaderInterval &)obj;

  Comparison result;

  if ((result = m_requestType.Compare(other.m_requestType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_maximumHeaderInterval::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestType.GetObjectLength();
  return length;
}


BOOL H245_MultilinkRequest_maximumHeaderInterval::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkRequest_maximumHeaderInterval::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkRequest_maximumHeaderInterval::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_maximumHeaderInterval(*this);
}


//
// MultilinkResponse_addConnection
//

H245_MultilinkResponse_addConnection::H245_MultilinkResponse_addConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_addConnection::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+15) << "responseCode = " << setprecision(indent) << m_responseCode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_addConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkResponse_addConnection), PInvalidCast);
#endif
  const H245_MultilinkResponse_addConnection & other = (const H245_MultilinkResponse_addConnection &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_responseCode.Compare(other.m_responseCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_addConnection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_responseCode.GetObjectLength();
  return length;
}


BOOL H245_MultilinkResponse_addConnection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_responseCode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkResponse_addConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_responseCode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkResponse_addConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection(*this);
}


//
// SendTerminalCapabilitySet_specificRequest
//

H245_SendTerminalCapabilitySet_specificRequest::H245_SendTerminalCapabilitySet_specificRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_capabilityTableEntryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_capabilityDescriptorNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_SendTerminalCapabilitySet_specificRequest::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "multiplexCapability = " << setprecision(indent) << m_multiplexCapability << '\n';
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    strm << setw(indent+30) << "capabilityTableEntryNumbers = " << setprecision(indent) << m_capabilityTableEntryNumbers << '\n';
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    strm << setw(indent+30) << "capabilityDescriptorNumbers = " << setprecision(indent) << m_capabilityDescriptorNumbers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_SendTerminalCapabilitySet_specificRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_SendTerminalCapabilitySet_specificRequest), PInvalidCast);
#endif
  const H245_SendTerminalCapabilitySet_specificRequest & other = (const H245_SendTerminalCapabilitySet_specificRequest &)obj;

  Comparison result;

  if ((result = m_multiplexCapability.Compare(other.m_multiplexCapability)) != EqualTo)
    return result;
  if ((result = m_capabilityTableEntryNumbers.Compare(other.m_capabilityTableEntryNumbers)) != EqualTo)
    return result;
  if ((result = m_capabilityDescriptorNumbers.Compare(other.m_capabilityDescriptorNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_SendTerminalCapabilitySet_specificRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexCapability.GetObjectLength();
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    length += m_capabilityTableEntryNumbers.GetObjectLength();
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    length += m_capabilityDescriptorNumbers.GetObjectLength();
  return length;
}


BOOL H245_SendTerminalCapabilitySet_specificRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capabilityTableEntryNumbers) && !m_capabilityTableEntryNumbers.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_capabilityDescriptorNumbers) && !m_capabilityDescriptorNumbers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_SendTerminalCapabilitySet_specificRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    m_capabilityTableEntryNumbers.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    m_capabilityDescriptorNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_SendTerminalCapabilitySet_specificRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SendTerminalCapabilitySet_specificRequest::Class()), PInvalidCast);
#endif
  return new H245_SendTerminalCapabilitySet_specificRequest(*this);
}


//
// EncryptionCommand_encryptionAlgorithmID
//

H245_EncryptionCommand_encryptionAlgorithmID::H245_EncryptionCommand_encryptionAlgorithmID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_EncryptionCommand_encryptionAlgorithmID::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h233AlgorithmIdentifier = " << setprecision(indent) << m_h233AlgorithmIdentifier << '\n';
  strm << setw(indent+22) << "associatedAlgorithm = " << setprecision(indent) << m_associatedAlgorithm << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EncryptionCommand_encryptionAlgorithmID::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EncryptionCommand_encryptionAlgorithmID), PInvalidCast);
#endif
  const H245_EncryptionCommand_encryptionAlgorithmID & other = (const H245_EncryptionCommand_encryptionAlgorithmID &)obj;

  Comparison result;

  if ((result = m_h233AlgorithmIdentifier.Compare(other.m_h233AlgorithmIdentifier)) != EqualTo)
    return result;
  if ((result = m_associatedAlgorithm.Compare(other.m_associatedAlgorithm)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionCommand_encryptionAlgorithmID::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h233AlgorithmIdentifier.GetObjectLength();
  length += m_associatedAlgorithm.GetObjectLength();
  return length;
}


BOOL H245_EncryptionCommand_encryptionAlgorithmID::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h233AlgorithmIdentifier.Decode(strm))
    return FALSE;
  if (!m_associatedAlgorithm.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EncryptionCommand_encryptionAlgorithmID::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h233AlgorithmIdentifier.Encode(strm);
  m_associatedAlgorithm.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EncryptionCommand_encryptionAlgorithmID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCommand_encryptionAlgorithmID::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCommand_encryptionAlgorithmID(*this);
}


//
// NewATMVCCommand_reverseParameters
//

H245_NewATMVCCommand_reverseParameters::H245_NewATMVCCommand_reverseParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_reverseParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_reverseParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCCommand_reverseParameters), PInvalidCast);
#endif
  const H245_NewATMVCCommand_reverseParameters & other = (const H245_NewATMVCCommand_reverseParameters &)obj;

  Comparison result;

  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_reverseParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_bitRate.GetObjectLength();
  length += m_bitRateLockedToPCRClock.GetObjectLength();
  length += m_bitRateLockedToNetworkClock.GetObjectLength();
  length += m_multiplex.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCCommand_reverseParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToPCRClock.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToNetworkClock.Decode(strm))
    return FALSE;
  if (!m_multiplex.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCCommand_reverseParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCCommand_reverseParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_reverseParameters::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_reverseParameters(*this);
}


//
// NewATMVCIndication_reverseParameters
//

H245_NewATMVCIndication_reverseParameters::H245_NewATMVCIndication_reverseParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_reverseParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_reverseParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCIndication_reverseParameters), PInvalidCast);
#endif
  const H245_NewATMVCIndication_reverseParameters & other = (const H245_NewATMVCIndication_reverseParameters &)obj;

  Comparison result;

  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_reverseParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_bitRate.GetObjectLength();
  length += m_bitRateLockedToPCRClock.GetObjectLength();
  length += m_bitRateLockedToNetworkClock.GetObjectLength();
  length += m_multiplex.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCIndication_reverseParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToPCRClock.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToNetworkClock.Decode(strm))
    return FALSE;
  if (!m_multiplex.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCIndication_reverseParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCIndication_reverseParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_reverseParameters::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_reverseParameters(*this);
}


//
// UserInputIndication_signal
//

H245_UserInputIndication_signal::H245_UserInputIndication_signal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 4)
{
  m_signalType.SetConstraints(PASN_Object::FixedConstraint, 1);
  m_signalType.SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*ABCD!");
  m_duration.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_encryptedSignalType.SetConstraints(PASN_Object::FixedConstraint, 1);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signal::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "signalType = " << setprecision(indent) << m_signalType << '\n';
  if (HasOptionalField(e_duration))
    strm << setw(indent+11) << "duration = " << setprecision(indent) << m_duration << '\n';
  if (HasOptionalField(e_rtp))
    strm << setw(indent+6) << "rtp = " << setprecision(indent) << m_rtp << '\n';
  if (HasOptionalField(e_rtpPayloadIndication))
    strm << setw(indent+23) << "rtpPayloadIndication = " << setprecision(indent) << m_rtpPayloadIndication << '\n';
  if (HasOptionalField(e_paramS))
    strm << setw(indent+9) << "paramS = " << setprecision(indent) << m_paramS << '\n';
  if (HasOptionalField(e_encryptedSignalType))
    strm << setw(indent+22) << "encryptedSignalType = " << setprecision(indent) << m_encryptedSignalType << '\n';
  if (HasOptionalField(e_algorithmOID))
    strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signal::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_signal), PInvalidCast);
#endif
  const H245_UserInputIndication_signal & other = (const H245_UserInputIndication_signal &)obj;

  Comparison result;

  if ((result = m_signalType.Compare(other.m_signalType)) != EqualTo)
    return result;
  if ((result = m_duration.Compare(other.m_duration)) != EqualTo)
    return result;
  if ((result = m_rtp.Compare(other.m_rtp)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signal::GetDataLength() const
{
  PINDEX length = 0;
  length += m_signalType.GetObjectLength();
  if (HasOptionalField(e_duration))
    length += m_duration.GetObjectLength();
  if (HasOptionalField(e_rtp))
    length += m_rtp.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_signal::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_signalType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_duration) && !m_duration.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rtp) && !m_rtp.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rtpPayloadIndication, m_rtpPayloadIndication))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_paramS, m_paramS))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_encryptedSignalType, m_encryptedSignalType))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_algorithmOID, m_algorithmOID))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_signal::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalType.Encode(strm);
  if (HasOptionalField(e_duration))
    m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);
  KnownExtensionEncode(strm, e_rtpPayloadIndication, m_rtpPayloadIndication);
  KnownExtensionEncode(strm, e_paramS, m_paramS);
  KnownExtensionEncode(strm, e_encryptedSignalType, m_encryptedSignalType);
  KnownExtensionEncode(strm, e_algorithmOID, m_algorithmOID);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_signal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signal::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signal(*this);
}


//
// UserInputIndication_signalUpdate
//

H245_UserInputIndication_signalUpdate::H245_UserInputIndication_signalUpdate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_duration.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signalUpdate::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "duration = " << setprecision(indent) << m_duration << '\n';
  if (HasOptionalField(e_rtp))
    strm << setw(indent+6) << "rtp = " << setprecision(indent) << m_rtp << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signalUpdate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_signalUpdate), PInvalidCast);
#endif
  const H245_UserInputIndication_signalUpdate & other = (const H245_UserInputIndication_signalUpdate &)obj;

  Comparison result;

  if ((result = m_duration.Compare(other.m_duration)) != EqualTo)
    return result;
  if ((result = m_rtp.Compare(other.m_rtp)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signalUpdate::GetDataLength() const
{
  PINDEX length = 0;
  length += m_duration.GetObjectLength();
  if (HasOptionalField(e_rtp))
    length += m_rtp.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_signalUpdate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_duration.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rtp) && !m_rtp.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_signalUpdate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_signalUpdate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signalUpdate::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signalUpdate(*this);
}


//
// UserInputIndication_extendedAlphanumeric
//

H245_UserInputIndication_extendedAlphanumeric::H245_UserInputIndication_extendedAlphanumeric(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_extendedAlphanumeric::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "alphanumeric = " << setprecision(indent) << m_alphanumeric << '\n';
  if (HasOptionalField(e_rtpPayloadIndication))
    strm << setw(indent+23) << "rtpPayloadIndication = " << setprecision(indent) << m_rtpPayloadIndication << '\n';
  if (HasOptionalField(e_encryptedAlphanumeric))
    strm << setw(indent+24) << "encryptedAlphanumeric = " << setprecision(indent) << m_encryptedAlphanumeric << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_extendedAlphanumeric::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_extendedAlphanumeric), PInvalidCast);
#endif
  const H245_UserInputIndication_extendedAlphanumeric & other = (const H245_UserInputIndication_extendedAlphanumeric &)obj;

  Comparison result;

  if ((result = m_alphanumeric.Compare(other.m_alphanumeric)) != EqualTo)
    return result;
  if ((result = m_rtpPayloadIndication.Compare(other.m_rtpPayloadIndication)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_extendedAlphanumeric::GetDataLength() const
{
  PINDEX length = 0;
  length += m_alphanumeric.GetObjectLength();
  if (HasOptionalField(e_rtpPayloadIndication))
    length += m_rtpPayloadIndication.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_extendedAlphanumeric::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_alphanumeric.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rtpPayloadIndication) && !m_rtpPayloadIndication.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_encryptedAlphanumeric, m_encryptedAlphanumeric))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_extendedAlphanumeric::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_alphanumeric.Encode(strm);
  if (HasOptionalField(e_rtpPayloadIndication))
    m_rtpPayloadIndication.Encode(strm);
  KnownExtensionEncode(strm, e_encryptedAlphanumeric, m_encryptedAlphanumeric);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_extendedAlphanumeric::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_extendedAlphanumeric::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_extendedAlphanumeric(*this);
}


//
// V76LogicalChannelParameters_mode_eRM
//

H245_V76LogicalChannelParameters_mode_eRM::H245_V76LogicalChannelParameters_mode_eRM(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_windowSize.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
}


#ifndef PASN_NOPRINTON
void H245_V76LogicalChannelParameters_mode_eRM::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "windowSize = " << setprecision(indent) << m_windowSize << '\n';
  strm << setw(indent+11) << "recovery = " << setprecision(indent) << m_recovery << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V76LogicalChannelParameters_mode_eRM::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V76LogicalChannelParameters_mode_eRM), PInvalidCast);
#endif
  const H245_V76LogicalChannelParameters_mode_eRM & other = (const H245_V76LogicalChannelParameters_mode_eRM &)obj;

  Comparison result;

  if ((result = m_windowSize.Compare(other.m_windowSize)) != EqualTo)
    return result;
  if ((result = m_recovery.Compare(other.m_recovery)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76LogicalChannelParameters_mode_eRM::GetDataLength() const
{
  PINDEX length = 0;
  length += m_windowSize.GetObjectLength();
  length += m_recovery.GetObjectLength();
  return length;
}


BOOL H245_V76LogicalChannelParameters_mode_eRM::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_windowSize.Decode(strm))
    return FALSE;
  if (!m_recovery.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V76LogicalChannelParameters_mode_eRM::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_windowSize.Encode(strm);
  m_recovery.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V76LogicalChannelParameters_mode_eRM::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode_eRM::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode_eRM(*this);
}


//
// MiscellaneousCommand_type_progressiveRefinementStart
//

H245_MiscellaneousCommand_type_progressiveRefinementStart::H245_MiscellaneousCommand_type_progressiveRefinementStart(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_progressiveRefinementStart::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "repeatCount = " << setprecision(indent) << m_repeatCount << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_progressiveRefinementStart::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_progressiveRefinementStart), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_progressiveRefinementStart & other = (const H245_MiscellaneousCommand_type_progressiveRefinementStart &)obj;

  Comparison result;

  if ((result = m_repeatCount.Compare(other.m_repeatCount)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_progressiveRefinementStart::GetDataLength() const
{
  PINDEX length = 0;
  length += m_repeatCount.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_progressiveRefinementStart::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_repeatCount.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_progressiveRefinementStart::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_repeatCount.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_progressiveRefinementStart::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_progressiveRefinementStart::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_progressiveRefinementStart(*this);
}


//
// MiscellaneousCommand_type_encryptionUpdateCommand
//

H245_MiscellaneousCommand_type_encryptionUpdateCommand::H245_MiscellaneousCommand_type_encryptionUpdateCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_encryptionUpdateCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "encryptionSync = " << setprecision(indent) << m_encryptionSync << '\n';
  if (HasOptionalField(e_multiplePayloadStream))
    strm << setw(indent+24) << "multiplePayloadStream = " << setprecision(indent) << m_multiplePayloadStream << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_encryptionUpdateCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_encryptionUpdateCommand), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_encryptionUpdateCommand & other = (const H245_MiscellaneousCommand_type_encryptionUpdateCommand &)obj;

  Comparison result;

  if ((result = m_encryptionSync.Compare(other.m_encryptionSync)) != EqualTo)
    return result;
  if ((result = m_multiplePayloadStream.Compare(other.m_multiplePayloadStream)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_encryptionUpdateCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_encryptionSync.GetObjectLength();
  if (HasOptionalField(e_multiplePayloadStream))
    length += m_multiplePayloadStream.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_encryptionUpdateCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_encryptionSync.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_multiplePayloadStream) && !m_multiplePayloadStream.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_encryptionUpdateCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionSync.Encode(strm);
  if (HasOptionalField(e_multiplePayloadStream))
    m_multiplePayloadStream.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_encryptionUpdateCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_encryptionUpdateCommand::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_encryptionUpdateCommand(*this);
}


//
// NewATMVCCommand_aal_aal1
//

H245_NewATMVCCommand_aal_aal1::H245_NewATMVCCommand_aal_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_aal_aal1::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "clockRecovery = " << setprecision(indent) << m_clockRecovery << '\n';
  strm << setw(indent+18) << "errorCorrection = " << setprecision(indent) << m_errorCorrection << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_aal_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCCommand_aal_aal1), PInvalidCast);
#endif
  const H245_NewATMVCCommand_aal_aal1 & other = (const H245_NewATMVCCommand_aal_aal1 &)obj;

  Comparison result;

  if ((result = m_clockRecovery.Compare(other.m_clockRecovery)) != EqualTo)
    return result;
  if ((result = m_errorCorrection.Compare(other.m_errorCorrection)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_aal_aal1::GetDataLength() const
{
  PINDEX length = 0;
  length += m_clockRecovery.GetObjectLength();
  length += m_errorCorrection.GetObjectLength();
  length += m_structuredDataTransfer.GetObjectLength();
  length += m_partiallyFilledCells.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCCommand_aal_aal1::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_clockRecovery.Decode(strm))
    return FALSE;
  if (!m_errorCorrection.Decode(strm))
    return FALSE;
  if (!m_structuredDataTransfer.Decode(strm))
    return FALSE;
  if (!m_partiallyFilledCells.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCCommand_aal_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCCommand_aal_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1(*this);
}


//
// NewATMVCIndication_aal_aal1
//

H245_NewATMVCIndication_aal_aal1::H245_NewATMVCIndication_aal_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_aal_aal1::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "clockRecovery = " << setprecision(indent) << m_clockRecovery << '\n';
  strm << setw(indent+18) << "errorCorrection = " << setprecision(indent) << m_errorCorrection << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_aal_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCIndication_aal_aal1), PInvalidCast);
#endif
  const H245_NewATMVCIndication_aal_aal1 & other = (const H245_NewATMVCIndication_aal_aal1 &)obj;

  Comparison result;

  if ((result = m_clockRecovery.Compare(other.m_clockRecovery)) != EqualTo)
    return result;
  if ((result = m_errorCorrection.Compare(other.m_errorCorrection)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_aal_aal1::GetDataLength() const
{
  PINDEX length = 0;
  length += m_clockRecovery.GetObjectLength();
  length += m_errorCorrection.GetObjectLength();
  length += m_structuredDataTransfer.GetObjectLength();
  length += m_partiallyFilledCells.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCIndication_aal_aal1::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_clockRecovery.Decode(strm))
    return FALSE;
  if (!m_errorCorrection.Decode(strm))
    return FALSE;
  if (!m_structuredDataTransfer.Decode(strm))
    return FALSE;
  if (!m_partiallyFilledCells.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCIndication_aal_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCIndication_aal_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1(*this);
}


//
// NonStandardMessage
//

H245_NonStandardMessage::H245_NonStandardMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NonStandardMessage::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NonStandardMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NonStandardMessage), PInvalidCast);
#endif
  const H245_NonStandardMessage & other = (const H245_NonStandardMessage &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardMessage::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H245_NonStandardMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NonStandardMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NonStandardMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return new H245_NonStandardMessage(*this);
}


//
// VCCapability
//

H245_VCCapability::H245_VCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_aal1))
    strm << setw(indent+7) << "aal1 = " << setprecision(indent) << m_aal1 << '\n';
  if (HasOptionalField(e_aal5))
    strm << setw(indent+7) << "aal5 = " << setprecision(indent) << m_aal5 << '\n';
  strm << setw(indent+18) << "transportStream = " << setprecision(indent) << m_transportStream << '\n';
  strm << setw(indent+16) << "programStream = " << setprecision(indent) << m_programStream << '\n';
  strm << setw(indent+20) << "availableBitRates = " << setprecision(indent) << m_availableBitRates << '\n';
  if (HasOptionalField(e_aal1ViaGateway))
    strm << setw(indent+17) << "aal1ViaGateway = " << setprecision(indent) << m_aal1ViaGateway << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability), PInvalidCast);
#endif
  const H245_VCCapability & other = (const H245_VCCapability &)obj;

  Comparison result;

  if ((result = m_aal1.Compare(other.m_aal1)) != EqualTo)
    return result;
  if ((result = m_aal5.Compare(other.m_aal5)) != EqualTo)
    return result;
  if ((result = m_transportStream.Compare(other.m_transportStream)) != EqualTo)
    return result;
  if ((result = m_programStream.Compare(other.m_programStream)) != EqualTo)
    return result;
  if ((result = m_availableBitRates.Compare(other.m_availableBitRates)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_aal1))
    length += m_aal1.GetObjectLength();
  if (HasOptionalField(e_aal5))
    length += m_aal5.GetObjectLength();
  length += m_transportStream.GetObjectLength();
  length += m_programStream.GetObjectLength();
  length += m_availableBitRates.GetObjectLength();
  return length;
}


BOOL H245_VCCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_aal1) && !m_aal1.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_aal5) && !m_aal5.Decode(strm))
    return FALSE;
  if (!m_transportStream.Decode(strm))
    return FALSE;
  if (!m_programStream.Decode(strm))
    return FALSE;
  if (!m_availableBitRates.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_aal1ViaGateway, m_aal1ViaGateway))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_aal1))
    m_aal1.Encode(strm);
  if (HasOptionalField(e_aal5))
    m_aal5.Encode(strm);
  m_transportStream.Encode(strm);
  m_programStream.Encode(strm);
  m_availableBitRates.Encode(strm);
  KnownExtensionEncode(strm, e_aal1ViaGateway, m_aal1ViaGateway);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability::Class()), PInvalidCast);
#endif
  return new H245_VCCapability(*this);
}


//
// H2250Capability
//

H245_H2250Capability::H245_H2250Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_maximumAudioDelayJitter.SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
  m_redundancyEncodingCapability.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  IncludeOptionalField(e_logicalChannelSwitchingCapability);
  IncludeOptionalField(e_t120DynamicPortCapability);
}


#ifndef PASN_NOPRINTON
void H245_H2250Capability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "maximumAudioDelayJitter = " << setprecision(indent) << m_maximumAudioDelayJitter << '\n';
  strm << setw(indent+30) << "receiveMultipointCapability = " << setprecision(indent) << m_receiveMultipointCapability << '\n';
  strm << setw(indent+31) << "transmitMultipointCapability = " << setprecision(indent) << m_transmitMultipointCapability << '\n';
  strm << setw(indent+41) << "receiveAndTransmitMultipointCapability = " << setprecision(indent) << m_receiveAndTransmitMultipointCapability << '\n';
  strm << setw(indent+15) << "mcCapability = " << setprecision(indent) << m_mcCapability << '\n';
  strm << setw(indent+29) << "rtcpVideoControlCapability = " << setprecision(indent) << m_rtcpVideoControlCapability << '\n';
  strm << setw(indent+31) << "mediaPacketizationCapability = " << setprecision(indent) << m_mediaPacketizationCapability << '\n';
  if (HasOptionalField(e_transportCapability))
    strm << setw(indent+22) << "transportCapability = " << setprecision(indent) << m_transportCapability << '\n';
  if (HasOptionalField(e_redundancyEncodingCapability))
    strm << setw(indent+31) << "redundancyEncodingCapability = " << setprecision(indent) << m_redundancyEncodingCapability << '\n';
  if (HasOptionalField(e_logicalChannelSwitchingCapability))
    strm << setw(indent+36) << "logicalChannelSwitchingCapability = " << setprecision(indent) << m_logicalChannelSwitchingCapability << '\n';
  if (HasOptionalField(e_t120DynamicPortCapability))
    strm << setw(indent+28) << "t120DynamicPortCapability = " << setprecision(indent) << m_t120DynamicPortCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250Capability), PInvalidCast);
#endif
  const H245_H2250Capability & other = (const H245_H2250Capability &)obj;

  Comparison result;

  if ((result = m_maximumAudioDelayJitter.Compare(other.m_maximumAudioDelayJitter)) != EqualTo)
    return result;
  if ((result = m_receiveMultipointCapability.Compare(other.m_receiveMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_transmitMultipointCapability.Compare(other.m_transmitMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_receiveAndTransmitMultipointCapability.Compare(other.m_receiveAndTransmitMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_mcCapability.Compare(other.m_mcCapability)) != EqualTo)
    return result;
  if ((result = m_rtcpVideoControlCapability.Compare(other.m_rtcpVideoControlCapability)) != EqualTo)
    return result;
  if ((result = m_mediaPacketizationCapability.Compare(other.m_mediaPacketizationCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250Capability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maximumAudioDelayJitter.GetObjectLength();
  length += m_receiveMultipointCapability.GetObjectLength();
  length += m_transmitMultipointCapability.GetObjectLength();
  length += m_receiveAndTransmitMultipointCapability.GetObjectLength();
  length += m_mcCapability.GetObjectLength();
  length += m_rtcpVideoControlCapability.GetObjectLength();
  length += m_mediaPacketizationCapability.GetObjectLength();
  return length;
}


BOOL H245_H2250Capability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maximumAudioDelayJitter.Decode(strm))
    return FALSE;
  if (!m_receiveMultipointCapability.Decode(strm))
    return FALSE;
  if (!m_transmitMultipointCapability.Decode(strm))
    return FALSE;
  if (!m_receiveAndTransmitMultipointCapability.Decode(strm))
    return FALSE;
  if (!m_mcCapability.Decode(strm))
    return FALSE;
  if (!m_rtcpVideoControlCapability.Decode(strm))
    return FALSE;
  if (!m_mediaPacketizationCapability.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_transportCapability, m_transportCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_redundancyEncodingCapability, m_redundancyEncodingCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_logicalChannelSwitchingCapability, m_logicalChannelSwitchingCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_t120DynamicPortCapability, m_t120DynamicPortCapability))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maximumAudioDelayJitter.Encode(strm);
  m_receiveMultipointCapability.Encode(strm);
  m_transmitMultipointCapability.Encode(strm);
  m_receiveAndTransmitMultipointCapability.Encode(strm);
  m_mcCapability.Encode(strm);
  m_rtcpVideoControlCapability.Encode(strm);
  m_mediaPacketizationCapability.Encode(strm);
  KnownExtensionEncode(strm, e_transportCapability, m_transportCapability);
  KnownExtensionEncode(strm, e_redundancyEncodingCapability, m_redundancyEncodingCapability);
  KnownExtensionEncode(strm, e_logicalChannelSwitchingCapability, m_logicalChannelSwitchingCapability);
  KnownExtensionEncode(strm, e_t120DynamicPortCapability, m_t120DynamicPortCapability);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250Capability::Class()), PInvalidCast);
#endif
  return new H245_H2250Capability(*this);
}


//
// RefPictureSelection
//

H245_RefPictureSelection::H245_RefPictureSelection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
  IncludeOptionalField(e_enhancedReferencePicSelect);
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_additionalPictureMemory))
    strm << setw(indent+26) << "additionalPictureMemory = " << setprecision(indent) << m_additionalPictureMemory << '\n';
  strm << setw(indent+11) << "videoMux = " << setprecision(indent) << m_videoMux << '\n';
  strm << setw(indent+23) << "videoBackChannelSend = " << setprecision(indent) << m_videoBackChannelSend << '\n';
  if (HasOptionalField(e_enhancedReferencePicSelect))
    strm << setw(indent+29) << "enhancedReferencePicSelect = " << setprecision(indent) << m_enhancedReferencePicSelect << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RefPictureSelection), PInvalidCast);
#endif
  const H245_RefPictureSelection & other = (const H245_RefPictureSelection &)obj;

  Comparison result;

  if ((result = m_additionalPictureMemory.Compare(other.m_additionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_videoMux.Compare(other.m_videoMux)) != EqualTo)
    return result;
  if ((result = m_videoBackChannelSend.Compare(other.m_videoBackChannelSend)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_additionalPictureMemory))
    length += m_additionalPictureMemory.GetObjectLength();
  length += m_videoMux.GetObjectLength();
  length += m_videoBackChannelSend.GetObjectLength();
  return length;
}


BOOL H245_RefPictureSelection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_additionalPictureMemory) && !m_additionalPictureMemory.Decode(strm))
    return FALSE;
  if (!m_videoMux.Decode(strm))
    return FALSE;
  if (!m_videoBackChannelSend.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RefPictureSelection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_additionalPictureMemory))
    m_additionalPictureMemory.Encode(strm);
  m_videoMux.Encode(strm);
  m_videoBackChannelSend.Encode(strm);
  KnownExtensionEncode(strm, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RefPictureSelection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection(*this);
}


//
// CustomPictureFormat
//

H245_CustomPictureFormat::H245_CustomPictureFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxCustomPictureWidth.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_maxCustomPictureHeight.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_minCustomPictureWidth.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_minCustomPictureHeight.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "maxCustomPictureWidth = " << setprecision(indent) << m_maxCustomPictureWidth << '\n';
  strm << setw(indent+25) << "maxCustomPictureHeight = " << setprecision(indent) << m_maxCustomPictureHeight << '\n';
  strm << setw(indent+24) << "minCustomPictureWidth = " << setprecision(indent) << m_minCustomPictureWidth << '\n';
  strm << setw(indent+25) << "minCustomPictureHeight = " << setprecision(indent) << m_minCustomPictureHeight << '\n';
  strm << setw(indent+6) << "mPI = " << setprecision(indent) << m_mPI << '\n';
  strm << setw(indent+25) << "pixelAspectInformation = " << setprecision(indent) << m_pixelAspectInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CustomPictureFormat), PInvalidCast);
#endif
  const H245_CustomPictureFormat & other = (const H245_CustomPictureFormat &)obj;

  Comparison result;

  if ((result = m_maxCustomPictureWidth.Compare(other.m_maxCustomPictureWidth)) != EqualTo)
    return result;
  if ((result = m_maxCustomPictureHeight.Compare(other.m_maxCustomPictureHeight)) != EqualTo)
    return result;
  if ((result = m_minCustomPictureWidth.Compare(other.m_minCustomPictureWidth)) != EqualTo)
    return result;
  if ((result = m_minCustomPictureHeight.Compare(other.m_minCustomPictureHeight)) != EqualTo)
    return result;
  if ((result = m_mPI.Compare(other.m_mPI)) != EqualTo)
    return result;
  if ((result = m_pixelAspectInformation.Compare(other.m_pixelAspectInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxCustomPictureWidth.GetObjectLength();
  length += m_maxCustomPictureHeight.GetObjectLength();
  length += m_minCustomPictureWidth.GetObjectLength();
  length += m_minCustomPictureHeight.GetObjectLength();
  length += m_mPI.GetObjectLength();
  length += m_pixelAspectInformation.GetObjectLength();
  return length;
}


BOOL H245_CustomPictureFormat::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxCustomPictureWidth.Decode(strm))
    return FALSE;
  if (!m_maxCustomPictureHeight.Decode(strm))
    return FALSE;
  if (!m_minCustomPictureWidth.Decode(strm))
    return FALSE;
  if (!m_minCustomPictureHeight.Decode(strm))
    return FALSE;
  if (!m_mPI.Decode(strm))
    return FALSE;
  if (!m_pixelAspectInformation.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CustomPictureFormat::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxCustomPictureWidth.Encode(strm);
  m_maxCustomPictureHeight.Encode(strm);
  m_minCustomPictureWidth.Encode(strm);
  m_minCustomPictureHeight.Encode(strm);
  m_mPI.Encode(strm);
  m_pixelAspectInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CustomPictureFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat(*this);
}


//
// H263VideoModeCombos
//

H245_H263VideoModeCombos::H245_H263VideoModeCombos(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_h263VideoCoupledModes.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoModeCombos::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h263VideoUncoupledModes = " << setprecision(indent) << m_h263VideoUncoupledModes << '\n';
  strm << setw(indent+24) << "h263VideoCoupledModes = " << setprecision(indent) << m_h263VideoCoupledModes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263VideoModeCombos::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263VideoModeCombos), PInvalidCast);
#endif
  const H245_H263VideoModeCombos & other = (const H245_H263VideoModeCombos &)obj;

  Comparison result;

  if ((result = m_h263VideoUncoupledModes.Compare(other.m_h263VideoUncoupledModes)) != EqualTo)
    return result;
  if ((result = m_h263VideoCoupledModes.Compare(other.m_h263VideoCoupledModes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoModeCombos::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h263VideoUncoupledModes.GetObjectLength();
  length += m_h263VideoCoupledModes.GetObjectLength();
  return length;
}


BOOL H245_H263VideoModeCombos::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h263VideoUncoupledModes.Decode(strm))
    return FALSE;
  if (!m_h263VideoCoupledModes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263VideoModeCombos::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h263VideoUncoupledModes.Encode(strm);
  m_h263VideoCoupledModes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263VideoModeCombos::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoModeCombos::Class()), PInvalidCast);
#endif
  return new H245_H263VideoModeCombos(*this);
}


//
// T38FaxProfile
//

H245_T38FaxProfile::H245_T38FaxProfile(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_version.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  IncludeOptionalField(e_version);
  IncludeOptionalField(e_t38FaxRateManagement);
}


#ifndef PASN_NOPRINTON
void H245_T38FaxProfile::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "fillBitRemoval = " << setprecision(indent) << m_fillBitRemoval << '\n';
  strm << setw(indent+18) << "transcodingJBIG = " << setprecision(indent) << m_transcodingJBIG << '\n';
  strm << setw(indent+17) << "transcodingMMR = " << setprecision(indent) << m_transcodingMMR << '\n';
  if (HasOptionalField(e_version))
    strm << setw(indent+10) << "version = " << setprecision(indent) << m_version << '\n';
  if (HasOptionalField(e_t38FaxRateManagement))
    strm << setw(indent+23) << "t38FaxRateManagement = " << setprecision(indent) << m_t38FaxRateManagement << '\n';
  if (HasOptionalField(e_t38FaxUdpOptions))
    strm << setw(indent+19) << "t38FaxUdpOptions = " << setprecision(indent) << m_t38FaxUdpOptions << '\n';
  if (HasOptionalField(e_t38FaxTcpOptions))
    strm << setw(indent+19) << "t38FaxTcpOptions = " << setprecision(indent) << m_t38FaxTcpOptions << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_T38FaxProfile::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_T38FaxProfile), PInvalidCast);
#endif
  const H245_T38FaxProfile & other = (const H245_T38FaxProfile &)obj;

  Comparison result;

  if ((result = m_fillBitRemoval.Compare(other.m_fillBitRemoval)) != EqualTo)
    return result;
  if ((result = m_transcodingJBIG.Compare(other.m_transcodingJBIG)) != EqualTo)
    return result;
  if ((result = m_transcodingMMR.Compare(other.m_transcodingMMR)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T38FaxProfile::GetDataLength() const
{
  PINDEX length = 0;
  length += m_fillBitRemoval.GetObjectLength();
  length += m_transcodingJBIG.GetObjectLength();
  length += m_transcodingMMR.GetObjectLength();
  return length;
}


BOOL H245_T38FaxProfile::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_fillBitRemoval.Decode(strm))
    return FALSE;
  if (!m_transcodingJBIG.Decode(strm))
    return FALSE;
  if (!m_transcodingMMR.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_version, m_version))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_t38FaxRateManagement, m_t38FaxRateManagement))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_t38FaxUdpOptions, m_t38FaxUdpOptions))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_t38FaxTcpOptions, m_t38FaxTcpOptions))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_T38FaxProfile::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_fillBitRemoval.Encode(strm);
  m_transcodingJBIG.Encode(strm);
  m_transcodingMMR.Encode(strm);
  KnownExtensionEncode(strm, e_version, m_version);
  KnownExtensionEncode(strm, e_t38FaxRateManagement, m_t38FaxRateManagement);
  KnownExtensionEncode(strm, e_t38FaxUdpOptions, m_t38FaxUdpOptions);
  KnownExtensionEncode(strm, e_t38FaxTcpOptions, m_t38FaxTcpOptions);

  UnknownExtensionsEncode(strm);
}


PObject * H245_T38FaxProfile::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxProfile::Class()), PInvalidCast);
#endif
  return new H245_T38FaxProfile(*this);
}


//
// EncryptionAuthenticationAndIntegrity
//

H245_EncryptionAuthenticationAndIntegrity::H245_EncryptionAuthenticationAndIntegrity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_EncryptionAuthenticationAndIntegrity::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_encryptionCapability))
    strm << setw(indent+23) << "encryptionCapability = " << setprecision(indent) << m_encryptionCapability << '\n';
  if (HasOptionalField(e_authenticationCapability))
    strm << setw(indent+27) << "authenticationCapability = " << setprecision(indent) << m_authenticationCapability << '\n';
  if (HasOptionalField(e_integrityCapability))
    strm << setw(indent+22) << "integrityCapability = " << setprecision(indent) << m_integrityCapability << '\n';
  if (HasOptionalField(e_genericH235SecurityCapability))
    strm << setw(indent+32) << "genericH235SecurityCapability = " << setprecision(indent) << m_genericH235SecurityCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EncryptionAuthenticationAndIntegrity::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EncryptionAuthenticationAndIntegrity), PInvalidCast);
#endif
  const H245_EncryptionAuthenticationAndIntegrity & other = (const H245_EncryptionAuthenticationAndIntegrity &)obj;

  Comparison result;

  if ((result = m_encryptionCapability.Compare(other.m_encryptionCapability)) != EqualTo)
    return result;
  if ((result = m_authenticationCapability.Compare(other.m_authenticationCapability)) != EqualTo)
    return result;
  if ((result = m_integrityCapability.Compare(other.m_integrityCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionAuthenticationAndIntegrity::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_encryptionCapability))
    length += m_encryptionCapability.GetObjectLength();
  if (HasOptionalField(e_authenticationCapability))
    length += m_authenticationCapability.GetObjectLength();
  if (HasOptionalField(e_integrityCapability))
    length += m_integrityCapability.GetObjectLength();
  return length;
}


BOOL H245_EncryptionAuthenticationAndIntegrity::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_encryptionCapability) && !m_encryptionCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_authenticationCapability) && !m_authenticationCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCapability) && !m_integrityCapability.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericH235SecurityCapability, m_genericH235SecurityCapability))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EncryptionAuthenticationAndIntegrity::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_encryptionCapability))
    m_encryptionCapability.Encode(strm);
  if (HasOptionalField(e_authenticationCapability))
    m_authenticationCapability.Encode(strm);
  if (HasOptionalField(e_integrityCapability))
    m_integrityCapability.Encode(strm);
  KnownExtensionEncode(strm, e_genericH235SecurityCapability, m_genericH235SecurityCapability);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EncryptionAuthenticationAndIntegrity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionAuthenticationAndIntegrity::Class()), PInvalidCast);
#endif
  return new H245_EncryptionAuthenticationAndIntegrity(*this);
}


//
// OpenLogicalChannel
//

H245_OpenLogicalChannel::H245_OpenLogicalChannel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+34) << "forwardLogicalChannelParameters = " << setprecision(indent) << m_forwardLogicalChannelParameters << '\n';
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    strm << setw(indent+34) << "reverseLogicalChannelParameters = " << setprecision(indent) << m_reverseLogicalChannelParameters << '\n';
  if (HasOptionalField(e_separateStack))
    strm << setw(indent+16) << "separateStack = " << setprecision(indent) << m_separateStack << '\n';
  if (HasOptionalField(e_encryptionSync))
    strm << setw(indent+17) << "encryptionSync = " << setprecision(indent) << m_encryptionSync << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannel), PInvalidCast);
#endif
  const H245_OpenLogicalChannel & other = (const H245_OpenLogicalChannel &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_forwardLogicalChannelParameters.Compare(other.m_forwardLogicalChannelParameters)) != EqualTo)
    return result;
  if ((result = m_reverseLogicalChannelParameters.Compare(other.m_reverseLogicalChannelParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  length += m_forwardLogicalChannelParameters.GetObjectLength();
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    length += m_reverseLogicalChannelParameters.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannel::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_forwardLogicalChannelParameters.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reverseLogicalChannelParameters) && !m_reverseLogicalChannelParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_separateStack, m_separateStack))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_encryptionSync, m_encryptionSync))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_forwardLogicalChannelParameters.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
  KnownExtensionEncode(strm, e_separateStack, m_separateStack);
  KnownExtensionEncode(strm, e_encryptionSync, m_encryptionSync);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel(*this);
}


//
// H235Media
//

H245_H235Media::H245_H235Media(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235Media::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+12) << "mediaType = " << setprecision(indent) << m_mediaType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H235Media::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H235Media), PInvalidCast);
#endif
  const H245_H235Media & other = (const H245_H235Media &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaType.Compare(other.m_mediaType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235Media::GetDataLength() const
{
  PINDEX length = 0;
  length += m_encryptionAuthenticationAndIntegrity.GetObjectLength();
  length += m_mediaType.GetObjectLength();
  return length;
}


BOOL H245_H235Media::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_encryptionAuthenticationAndIntegrity.Decode(strm))
    return FALSE;
  if (!m_mediaType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H235Media::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H235Media::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Media::Class()), PInvalidCast);
#endif
  return new H245_H235Media(*this);
}


//
// V76LogicalChannelParameters
//

H245_V76LogicalChannelParameters::H245_V76LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V76LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "hdlcParameters = " << setprecision(indent) << m_hdlcParameters << '\n';
  strm << setw(indent+16) << "suspendResume = " << setprecision(indent) << m_suspendResume << '\n';
  strm << setw(indent+6) << "uIH = " << setprecision(indent) << m_uIH << '\n';
  strm << setw(indent+7) << "mode = " << setprecision(indent) << m_mode << '\n';
  strm << setw(indent+16) << "v75Parameters = " << setprecision(indent) << m_v75Parameters << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V76LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V76LogicalChannelParameters), PInvalidCast);
#endif
  const H245_V76LogicalChannelParameters & other = (const H245_V76LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_hdlcParameters.Compare(other.m_hdlcParameters)) != EqualTo)
    return result;
  if ((result = m_suspendResume.Compare(other.m_suspendResume)) != EqualTo)
    return result;
  if ((result = m_uIH.Compare(other.m_uIH)) != EqualTo)
    return result;
  if ((result = m_mode.Compare(other.m_mode)) != EqualTo)
    return result;
  if ((result = m_v75Parameters.Compare(other.m_v75Parameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76LogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_hdlcParameters.GetObjectLength();
  length += m_suspendResume.GetObjectLength();
  length += m_uIH.GetObjectLength();
  length += m_mode.GetObjectLength();
  length += m_v75Parameters.GetObjectLength();
  return length;
}


BOOL H245_V76LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_hdlcParameters.Decode(strm))
    return FALSE;
  if (!m_suspendResume.Decode(strm))
    return FALSE;
  if (!m_uIH.Decode(strm))
    return FALSE;
  if (!m_mode.Decode(strm))
    return FALSE;
  if (!m_v75Parameters.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V76LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_hdlcParameters.Encode(strm);
  m_suspendResume.Encode(strm);
  m_uIH.Encode(strm);
  m_mode.Encode(strm);
  m_v75Parameters.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V76LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters(*this);
}


//
// RedundancyEncoding
//

H245_RedundancyEncoding::H245_RedundancyEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncoding::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  if (HasOptionalField(e_rtpRedundancyEncoding))
    strm << setw(indent+24) << "rtpRedundancyEncoding = " << setprecision(indent) << m_rtpRedundancyEncoding << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncoding::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncoding), PInvalidCast);
#endif
  const H245_RedundancyEncoding & other = (const H245_RedundancyEncoding &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncoding::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redundancyEncodingMethod.GetObjectLength();
  if (HasOptionalField(e_secondaryEncoding))
    length += m_secondaryEncoding.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncoding::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_redundancyEncodingMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_secondaryEncoding) && !m_secondaryEncoding.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rtpRedundancyEncoding, m_rtpRedundancyEncoding))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncoding::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);
  KnownExtensionEncode(strm, e_rtpRedundancyEncoding, m_rtpRedundancyEncoding);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncoding::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncoding(*this);
}


//
// OpenLogicalChannelAck
//

H245_OpenLogicalChannelAck::H245_OpenLogicalChannelAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelAck::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    strm << setw(indent+34) << "reverseLogicalChannelParameters = " << setprecision(indent) << m_reverseLogicalChannelParameters << '\n';
  if (HasOptionalField(e_separateStack))
    strm << setw(indent+16) << "separateStack = " << setprecision(indent) << m_separateStack << '\n';
  if (HasOptionalField(e_forwardMultiplexAckParameters))
    strm << setw(indent+32) << "forwardMultiplexAckParameters = " << setprecision(indent) << m_forwardMultiplexAckParameters << '\n';
  if (HasOptionalField(e_encryptionSync))
    strm << setw(indent+17) << "encryptionSync = " << setprecision(indent) << m_encryptionSync << '\n';
  if (HasOptionalField(e_genericInformation))
    strm << setw(indent+21) << "genericInformation = " << setprecision(indent) << m_genericInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannelAck), PInvalidCast);
#endif
  const H245_OpenLogicalChannelAck & other = (const H245_OpenLogicalChannelAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_reverseLogicalChannelParameters.Compare(other.m_reverseLogicalChannelParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    length += m_reverseLogicalChannelParameters.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannelAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reverseLogicalChannelParameters) && !m_reverseLogicalChannelParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_separateStack, m_separateStack))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_forwardMultiplexAckParameters, m_forwardMultiplexAckParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_encryptionSync, m_encryptionSync))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericInformation, m_genericInformation))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannelAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
  KnownExtensionEncode(strm, e_separateStack, m_separateStack);
  KnownExtensionEncode(strm, e_forwardMultiplexAckParameters, m_forwardMultiplexAckParameters);
  KnownExtensionEncode(strm, e_encryptionSync, m_encryptionSync);
  KnownExtensionEncode(strm, e_genericInformation, m_genericInformation);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannelAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck(*this);
}


//
// H235Mode
//

H245_H235Mode::H245_H235Mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235Mode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+12) << "mediaMode = " << setprecision(indent) << m_mediaMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H235Mode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H235Mode), PInvalidCast);
#endif
  const H245_H235Mode & other = (const H245_H235Mode &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaMode.Compare(other.m_mediaMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235Mode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_encryptionAuthenticationAndIntegrity.GetObjectLength();
  length += m_mediaMode.GetObjectLength();
  return length;
}


BOOL H245_H235Mode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_encryptionAuthenticationAndIntegrity.Decode(strm))
    return FALSE;
  if (!m_mediaMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H235Mode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H235Mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Mode::Class()), PInvalidCast);
#endif
  return new H245_H235Mode(*this);
}


//
// RedundancyEncodingDTMode
//

H245_RedundancyEncodingDTMode::H245_RedundancyEncodingDTMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingDTMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  strm << setw(indent+10) << "primary = " << setprecision(indent) << m_primary << '\n';
  strm << setw(indent+12) << "secondary = " << setprecision(indent) << m_secondary << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingDTMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncodingDTMode), PInvalidCast);
#endif
  const H245_RedundancyEncodingDTMode & other = (const H245_RedundancyEncodingDTMode &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_primary.Compare(other.m_primary)) != EqualTo)
    return result;
  if ((result = m_secondary.Compare(other.m_secondary)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingDTMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redundancyEncodingMethod.GetObjectLength();
  length += m_primary.GetObjectLength();
  length += m_secondary.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncodingDTMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_redundancyEncodingMethod.Decode(strm))
    return FALSE;
  if (!m_primary.Decode(strm))
    return FALSE;
  if (!m_secondary.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncodingDTMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  m_primary.Encode(strm);
  m_secondary.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncodingDTMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingDTMode::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingDTMode(*this);
}


//
// H2250ModeParameters
//

H245_H2250ModeParameters::H245_H2250ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H2250ModeParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_redundancyEncodingMode))
    strm << setw(indent+25) << "redundancyEncodingMode = " << setprecision(indent) << m_redundancyEncodingMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250ModeParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250ModeParameters), PInvalidCast);
#endif
  const H245_H2250ModeParameters & other = (const H245_H2250ModeParameters &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMode.Compare(other.m_redundancyEncodingMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250ModeParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_redundancyEncodingMode))
    length += m_redundancyEncodingMode.GetObjectLength();
  return length;
}


BOOL H245_H2250ModeParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_redundancyEncodingMode) && !m_redundancyEncodingMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250ModeParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_redundancyEncodingMode))
    m_redundancyEncodingMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250ModeParameters(*this);
}


//
// CommunicationModeTableEntry
//

H245_CommunicationModeTableEntry::H245_CommunicationModeTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 3)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_associatedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_sessionDescription.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
  m_sessionDependency.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeTableEntry::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_associatedSessionID))
    strm << setw(indent+22) << "associatedSessionID = " << setprecision(indent) << m_associatedSessionID << '\n';
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+21) << "sessionDescription = " << setprecision(indent) << m_sessionDescription << '\n';
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    strm << setw(indent+26) << "mediaGuaranteedDelivery = " << setprecision(indent) << m_mediaGuaranteedDelivery << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    strm << setw(indent+33) << "mediaControlGuaranteedDelivery = " << setprecision(indent) << m_mediaControlGuaranteedDelivery << '\n';
  if (HasOptionalField(e_redundancyEncoding))
    strm << setw(indent+21) << "redundancyEncoding = " << setprecision(indent) << m_redundancyEncoding << '\n';
  if (HasOptionalField(e_sessionDependency))
    strm << setw(indent+20) << "sessionDependency = " << setprecision(indent) << m_sessionDependency << '\n';
  if (HasOptionalField(e_destination))
    strm << setw(indent+14) << "destination = " << setprecision(indent) << m_destination << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CommunicationModeTableEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CommunicationModeTableEntry), PInvalidCast);
#endif
  const H245_CommunicationModeTableEntry & other = (const H245_CommunicationModeTableEntry &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_associatedSessionID.Compare(other.m_associatedSessionID)) != EqualTo)
    return result;
  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_sessionDescription.Compare(other.m_sessionDescription)) != EqualTo)
    return result;
  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaGuaranteedDelivery.Compare(other.m_mediaGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlGuaranteedDelivery.Compare(other.m_mediaControlGuaranteedDelivery)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CommunicationModeTableEntry::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  length += m_sessionID.GetObjectLength();
  if (HasOptionalField(e_associatedSessionID))
    length += m_associatedSessionID.GetObjectLength();
  if (HasOptionalField(e_terminalLabel))
    length += m_terminalLabel.GetObjectLength();
  length += m_sessionDescription.GetObjectLength();
  length += m_dataType.GetObjectLength();
  if (HasOptionalField(e_mediaChannel))
    length += m_mediaChannel.GetObjectLength();
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    length += m_mediaGuaranteedDelivery.GetObjectLength();
  if (HasOptionalField(e_mediaControlChannel))
    length += m_mediaControlChannel.GetObjectLength();
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    length += m_mediaControlGuaranteedDelivery.GetObjectLength();
  return length;
}


BOOL H245_CommunicationModeTableEntry::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!m_sessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_associatedSessionID) && !m_associatedSessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminalLabel) && !m_terminalLabel.Decode(strm))
    return FALSE;
  if (!m_sessionDescription.Decode(strm))
    return FALSE;
  if (!m_dataType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaChannel) && !m_mediaChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaGuaranteedDelivery) && !m_mediaGuaranteedDelivery.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaControlChannel) && !m_mediaControlChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaControlGuaranteedDelivery) && !m_mediaControlGuaranteedDelivery.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_redundancyEncoding, m_redundancyEncoding))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sessionDependency, m_sessionDependency))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destination, m_destination))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CommunicationModeTableEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  m_sessionDescription.Encode(strm);
  m_dataType.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
  KnownExtensionEncode(strm, e_redundancyEncoding, m_redundancyEncoding);
  KnownExtensionEncode(strm, e_sessionDependency, m_sessionDependency);
  KnownExtensionEncode(strm, e_destination, m_destination);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CommunicationModeTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeTableEntry(*this);
}


//
// NewATMVCCommand
//

H245_NewATMVCCommand::H245_NewATMVCCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+6) << "aal = " << setprecision(indent) << m_aal << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent+20) << "reverseParameters = " << setprecision(indent) << m_reverseParameters << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCCommand), PInvalidCast);
#endif
  const H245_NewATMVCCommand & other = (const H245_NewATMVCCommand &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_aal.Compare(other.m_aal)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;
  if ((result = m_reverseParameters.Compare(other.m_reverseParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_resourceID.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  length += m_bitRateLockedToPCRClock.GetObjectLength();
  length += m_bitRateLockedToNetworkClock.GetObjectLength();
  length += m_aal.GetObjectLength();
  length += m_multiplex.GetObjectLength();
  length += m_reverseParameters.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_resourceID.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToPCRClock.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToNetworkClock.Decode(strm))
    return FALSE;
  if (!m_aal.Decode(strm))
    return FALSE;
  if (!m_multiplex.Decode(strm))
    return FALSE;
  if (!m_reverseParameters.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
  m_reverseParameters.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand(*this);
}


//
// NewATMVCIndication
//

H245_NewATMVCIndication::H245_NewATMVCIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  IncludeOptionalField(e_reverseParameters);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+6) << "aal = " << setprecision(indent) << m_aal << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  if (HasOptionalField(e_reverseParameters))
    strm << setw(indent+20) << "reverseParameters = " << setprecision(indent) << m_reverseParameters << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCIndication), PInvalidCast);
#endif
  const H245_NewATMVCIndication & other = (const H245_NewATMVCIndication &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_aal.Compare(other.m_aal)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_resourceID.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  length += m_bitRateLockedToPCRClock.GetObjectLength();
  length += m_bitRateLockedToNetworkClock.GetObjectLength();
  length += m_aal.GetObjectLength();
  length += m_multiplex.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_resourceID.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToPCRClock.Decode(strm))
    return FALSE;
  if (!m_bitRateLockedToNetworkClock.Decode(strm))
    return FALSE;
  if (!m_aal.Decode(strm))
    return FALSE;
  if (!m_multiplex.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_reverseParameters, m_reverseParameters))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
  KnownExtensionEncode(strm, e_reverseParameters, m_reverseParameters);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication(*this);
}


//
// DataApplicationCapability_application_t38fax
//

H245_DataApplicationCapability_application_t38fax::H245_DataApplicationCapability_application_t38fax(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_t38fax::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_t38fax::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataApplicationCapability_application_t38fax), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_t38fax & other = (const H245_DataApplicationCapability_application_t38fax &)obj;

  Comparison result;

  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_t38fax::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t38FaxProtocol.GetObjectLength();
  length += m_t38FaxProfile.GetObjectLength();
  return length;
}


BOOL H245_DataApplicationCapability_application_t38fax::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t38FaxProtocol.Decode(strm))
    return FALSE;
  if (!m_t38FaxProfile.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataApplicationCapability_application_t38fax::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataApplicationCapability_application_t38fax::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_t38fax::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_t38fax(*this);
}


//
// DataMode_application_t38fax
//

H245_DataMode_application_t38fax::H245_DataMode_application_t38fax(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataMode_application_t38fax::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataMode_application_t38fax::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataMode_application_t38fax), PInvalidCast);
#endif
  const H245_DataMode_application_t38fax & other = (const H245_DataMode_application_t38fax &)obj;

  Comparison result;

  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode_application_t38fax::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t38FaxProtocol.GetObjectLength();
  length += m_t38FaxProfile.GetObjectLength();
  return length;
}


BOOL H245_DataMode_application_t38fax::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t38FaxProtocol.Decode(strm))
    return FALSE;
  if (!m_t38FaxProfile.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataMode_application_t38fax::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataMode_application_t38fax::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application_t38fax::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application_t38fax(*this);
}


//
// H235SecurityCapability
//

H245_H235SecurityCapability::H245_H235SecurityCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235SecurityCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+18) << "mediaCapability = " << setprecision(indent) << m_mediaCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H235SecurityCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H235SecurityCapability), PInvalidCast);
#endif
  const H245_H235SecurityCapability & other = (const H245_H235SecurityCapability &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaCapability.Compare(other.m_mediaCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235SecurityCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_encryptionAuthenticationAndIntegrity.GetObjectLength();
  length += m_mediaCapability.GetObjectLength();
  return length;
}


BOOL H245_H235SecurityCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_encryptionAuthenticationAndIntegrity.Decode(strm))
    return FALSE;
  if (!m_mediaCapability.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H235SecurityCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H235SecurityCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235SecurityCapability::Class()), PInvalidCast);
#endif
  return new H245_H235SecurityCapability(*this);
}


//
// H263Options
//

H245_H263Options::H245_H263Options(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 2)
{
  m_customPictureClockFrequency.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_customPictureFormat.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_modeCombos.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  IncludeOptionalField(e_videoBadMBsCap);
  IncludeOptionalField(e_h263Version3Options);
}


#ifndef PASN_NOPRINTON
void H245_H263Options::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "advancedIntraCodingMode = " << setprecision(indent) << m_advancedIntraCodingMode << '\n';
  strm << setw(indent+23) << "deblockingFilterMode = " << setprecision(indent) << m_deblockingFilterMode << '\n';
  strm << setw(indent+23) << "improvedPBFramesMode = " << setprecision(indent) << m_improvedPBFramesMode << '\n';
  strm << setw(indent+25) << "unlimitedMotionVectors = " << setprecision(indent) << m_unlimitedMotionVectors << '\n';
  strm << setw(indent+20) << "fullPictureFreeze = " << setprecision(indent) << m_fullPictureFreeze << '\n';
  strm << setw(indent+33) << "partialPictureFreezeAndRelease = " << setprecision(indent) << m_partialPictureFreezeAndRelease << '\n';
  strm << setw(indent+34) << "resizingPartPicFreezeAndRelease = " << setprecision(indent) << m_resizingPartPicFreezeAndRelease << '\n';
  strm << setw(indent+22) << "fullPictureSnapshot = " << setprecision(indent) << m_fullPictureSnapshot << '\n';
  strm << setw(indent+25) << "partialPictureSnapshot = " << setprecision(indent) << m_partialPictureSnapshot << '\n';
  strm << setw(indent+22) << "videoSegmentTagging = " << setprecision(indent) << m_videoSegmentTagging << '\n';
  strm << setw(indent+24) << "progressiveRefinement = " << setprecision(indent) << m_progressiveRefinement << '\n';
  strm << setw(indent+31) << "dynamicPictureResizingByFour = " << setprecision(indent) << m_dynamicPictureResizingByFour << '\n';
  strm << setw(indent+37) << "dynamicPictureResizingSixteenthPel = " << setprecision(indent) << m_dynamicPictureResizingSixteenthPel << '\n';
  strm << setw(indent+24) << "dynamicWarpingHalfPel = " << setprecision(indent) << m_dynamicWarpingHalfPel << '\n';
  strm << setw(indent+29) << "dynamicWarpingSixteenthPel = " << setprecision(indent) << m_dynamicWarpingSixteenthPel << '\n';
  strm << setw(indent+29) << "independentSegmentDecoding = " << setprecision(indent) << m_independentSegmentDecoding << '\n';
  strm << setw(indent+24) << "slicesInOrder_NonRect = " << setprecision(indent) << m_slicesInOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesInOrder_Rect = " << setprecision(indent) << m_slicesInOrder_Rect << '\n';
  strm << setw(indent+24) << "slicesNoOrder_NonRect = " << setprecision(indent) << m_slicesNoOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesNoOrder_Rect = " << setprecision(indent) << m_slicesNoOrder_Rect << '\n';
  strm << setw(indent+24) << "alternateInterVLCMode = " << setprecision(indent) << m_alternateInterVLCMode << '\n';
  strm << setw(indent+27) << "modifiedQuantizationMode = " << setprecision(indent) << m_modifiedQuantizationMode << '\n';
  strm << setw(indent+26) << "reducedResolutionUpdate = " << setprecision(indent) << m_reducedResolutionUpdate << '\n';
  if (HasOptionalField(e_transparencyParameters))
    strm << setw(indent+25) << "transparencyParameters = " << setprecision(indent) << m_transparencyParameters << '\n';
  strm << setw(indent+27) << "separateVideoBackChannel = " << setprecision(indent) << m_separateVideoBackChannel << '\n';
  if (HasOptionalField(e_refPictureSelection))
    strm << setw(indent+22) << "refPictureSelection = " << setprecision(indent) << m_refPictureSelection << '\n';
  if (HasOptionalField(e_customPictureClockFrequency))
    strm << setw(indent+30) << "customPictureClockFrequency = " << setprecision(indent) << m_customPictureClockFrequency << '\n';
  if (HasOptionalField(e_customPictureFormat))
    strm << setw(indent+22) << "customPictureFormat = " << setprecision(indent) << m_customPictureFormat << '\n';
  if (HasOptionalField(e_modeCombos))
    strm << setw(indent+13) << "modeCombos = " << setprecision(indent) << m_modeCombos << '\n';
  if (HasOptionalField(e_videoBadMBsCap))
    strm << setw(indent+17) << "videoBadMBsCap = " << setprecision(indent) << m_videoBadMBsCap << '\n';
  if (HasOptionalField(e_h263Version3Options))
    strm << setw(indent+22) << "h263Version3Options = " << setprecision(indent) << m_h263Version3Options << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263Options::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263Options), PInvalidCast);
#endif
  const H245_H263Options & other = (const H245_H263Options &)obj;

  Comparison result;

  if ((result = m_advancedIntraCodingMode.Compare(other.m_advancedIntraCodingMode)) != EqualTo)
    return result;
  if ((result = m_deblockingFilterMode.Compare(other.m_deblockingFilterMode)) != EqualTo)
    return result;
  if ((result = m_improvedPBFramesMode.Compare(other.m_improvedPBFramesMode)) != EqualTo)
    return result;
  if ((result = m_unlimitedMotionVectors.Compare(other.m_unlimitedMotionVectors)) != EqualTo)
    return result;
  if ((result = m_fullPictureFreeze.Compare(other.m_fullPictureFreeze)) != EqualTo)
    return result;
  if ((result = m_partialPictureFreezeAndRelease.Compare(other.m_partialPictureFreezeAndRelease)) != EqualTo)
    return result;
  if ((result = m_resizingPartPicFreezeAndRelease.Compare(other.m_resizingPartPicFreezeAndRelease)) != EqualTo)
    return result;
  if ((result = m_fullPictureSnapshot.Compare(other.m_fullPictureSnapshot)) != EqualTo)
    return result;
  if ((result = m_partialPictureSnapshot.Compare(other.m_partialPictureSnapshot)) != EqualTo)
    return result;
  if ((result = m_videoSegmentTagging.Compare(other.m_videoSegmentTagging)) != EqualTo)
    return result;
  if ((result = m_progressiveRefinement.Compare(other.m_progressiveRefinement)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingByFour.Compare(other.m_dynamicPictureResizingByFour)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingSixteenthPel.Compare(other.m_dynamicPictureResizingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingHalfPel.Compare(other.m_dynamicWarpingHalfPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingSixteenthPel.Compare(other.m_dynamicWarpingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_independentSegmentDecoding.Compare(other.m_independentSegmentDecoding)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_NonRect.Compare(other.m_slicesInOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_Rect.Compare(other.m_slicesInOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_NonRect.Compare(other.m_slicesNoOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_Rect.Compare(other.m_slicesNoOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_alternateInterVLCMode.Compare(other.m_alternateInterVLCMode)) != EqualTo)
    return result;
  if ((result = m_modifiedQuantizationMode.Compare(other.m_modifiedQuantizationMode)) != EqualTo)
    return result;
  if ((result = m_reducedResolutionUpdate.Compare(other.m_reducedResolutionUpdate)) != EqualTo)
    return result;
  if ((result = m_transparencyParameters.Compare(other.m_transparencyParameters)) != EqualTo)
    return result;
  if ((result = m_separateVideoBackChannel.Compare(other.m_separateVideoBackChannel)) != EqualTo)
    return result;
  if ((result = m_refPictureSelection.Compare(other.m_refPictureSelection)) != EqualTo)
    return result;
  if ((result = m_customPictureClockFrequency.Compare(other.m_customPictureClockFrequency)) != EqualTo)
    return result;
  if ((result = m_customPictureFormat.Compare(other.m_customPictureFormat)) != EqualTo)
    return result;
  if ((result = m_modeCombos.Compare(other.m_modeCombos)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263Options::GetDataLength() const
{
  PINDEX length = 0;
  length += m_advancedIntraCodingMode.GetObjectLength();
  length += m_deblockingFilterMode.GetObjectLength();
  length += m_improvedPBFramesMode.GetObjectLength();
  length += m_unlimitedMotionVectors.GetObjectLength();
  length += m_fullPictureFreeze.GetObjectLength();
  length += m_partialPictureFreezeAndRelease.GetObjectLength();
  length += m_resizingPartPicFreezeAndRelease.GetObjectLength();
  length += m_fullPictureSnapshot.GetObjectLength();
  length += m_partialPictureSnapshot.GetObjectLength();
  length += m_videoSegmentTagging.GetObjectLength();
  length += m_progressiveRefinement.GetObjectLength();
  length += m_dynamicPictureResizingByFour.GetObjectLength();
  length += m_dynamicPictureResizingSixteenthPel.GetObjectLength();
  length += m_dynamicWarpingHalfPel.GetObjectLength();
  length += m_dynamicWarpingSixteenthPel.GetObjectLength();
  length += m_independentSegmentDecoding.GetObjectLength();
  length += m_slicesInOrder_NonRect.GetObjectLength();
  length += m_slicesInOrder_Rect.GetObjectLength();
  length += m_slicesNoOrder_NonRect.GetObjectLength();
  length += m_slicesNoOrder_Rect.GetObjectLength();
  length += m_alternateInterVLCMode.GetObjectLength();
  length += m_modifiedQuantizationMode.GetObjectLength();
  length += m_reducedResolutionUpdate.GetObjectLength();
  if (HasOptionalField(e_transparencyParameters))
    length += m_transparencyParameters.GetObjectLength();
  length += m_separateVideoBackChannel.GetObjectLength();
  if (HasOptionalField(e_refPictureSelection))
    length += m_refPictureSelection.GetObjectLength();
  if (HasOptionalField(e_customPictureClockFrequency))
    length += m_customPictureClockFrequency.GetObjectLength();
  if (HasOptionalField(e_customPictureFormat))
    length += m_customPictureFormat.GetObjectLength();
  if (HasOptionalField(e_modeCombos))
    length += m_modeCombos.GetObjectLength();
  return length;
}


BOOL H245_H263Options::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_advancedIntraCodingMode.Decode(strm))
    return FALSE;
  if (!m_deblockingFilterMode.Decode(strm))
    return FALSE;
  if (!m_improvedPBFramesMode.Decode(strm))
    return FALSE;
  if (!m_unlimitedMotionVectors.Decode(strm))
    return FALSE;
  if (!m_fullPictureFreeze.Decode(strm))
    return FALSE;
  if (!m_partialPictureFreezeAndRelease.Decode(strm))
    return FALSE;
  if (!m_resizingPartPicFreezeAndRelease.Decode(strm))
    return FALSE;
  if (!m_fullPictureSnapshot.Decode(strm))
    return FALSE;
  if (!m_partialPictureSnapshot.Decode(strm))
    return FALSE;
  if (!m_videoSegmentTagging.Decode(strm))
    return FALSE;
  if (!m_progressiveRefinement.Decode(strm))
    return FALSE;
  if (!m_dynamicPictureResizingByFour.Decode(strm))
    return FALSE;
  if (!m_dynamicPictureResizingSixteenthPel.Decode(strm))
    return FALSE;
  if (!m_dynamicWarpingHalfPel.Decode(strm))
    return FALSE;
  if (!m_dynamicWarpingSixteenthPel.Decode(strm))
    return FALSE;
  if (!m_independentSegmentDecoding.Decode(strm))
    return FALSE;
  if (!m_slicesInOrder_NonRect.Decode(strm))
    return FALSE;
  if (!m_slicesInOrder_Rect.Decode(strm))
    return FALSE;
  if (!m_slicesNoOrder_NonRect.Decode(strm))
    return FALSE;
  if (!m_slicesNoOrder_Rect.Decode(strm))
    return FALSE;
  if (!m_alternateInterVLCMode.Decode(strm))
    return FALSE;
  if (!m_modifiedQuantizationMode.Decode(strm))
    return FALSE;
  if (!m_reducedResolutionUpdate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transparencyParameters) && !m_transparencyParameters.Decode(strm))
    return FALSE;
  if (!m_separateVideoBackChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_refPictureSelection) && !m_refPictureSelection.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_customPictureClockFrequency) && !m_customPictureClockFrequency.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_customPictureFormat) && !m_customPictureFormat.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_modeCombos) && !m_modeCombos.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_videoBadMBsCap, m_videoBadMBsCap))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h263Version3Options, m_h263Version3Options))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263Options::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_fullPictureFreeze.Encode(strm);
  m_partialPictureFreezeAndRelease.Encode(strm);
  m_resizingPartPicFreezeAndRelease.Encode(strm);
  m_fullPictureSnapshot.Encode(strm);
  m_partialPictureSnapshot.Encode(strm);
  m_videoSegmentTagging.Encode(strm);
  m_progressiveRefinement.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  if (HasOptionalField(e_transparencyParameters))
    m_transparencyParameters.Encode(strm);
  m_separateVideoBackChannel.Encode(strm);
  if (HasOptionalField(e_refPictureSelection))
    m_refPictureSelection.Encode(strm);
  if (HasOptionalField(e_customPictureClockFrequency))
    m_customPictureClockFrequency.Encode(strm);
  if (HasOptionalField(e_customPictureFormat))
    m_customPictureFormat.Encode(strm);
  if (HasOptionalField(e_modeCombos))
    m_modeCombos.Encode(strm);
  KnownExtensionEncode(strm, e_videoBadMBsCap, m_videoBadMBsCap);
  KnownExtensionEncode(strm, e_h263Version3Options, m_h263Version3Options);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263Options::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263Options::Class()), PInvalidCast);
#endif
  return new H245_H263Options(*this);
}


//
// H2250LogicalChannelParameters
//

H245_H2250LogicalChannelParameters::H245_H2250LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 10, TRUE, 3)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_associatedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
}


#ifndef PASN_NOPRINTON
void H245_H2250LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_associatedSessionID))
    strm << setw(indent+22) << "associatedSessionID = " << setprecision(indent) << m_associatedSessionID << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    strm << setw(indent+26) << "mediaGuaranteedDelivery = " << setprecision(indent) << m_mediaGuaranteedDelivery << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    strm << setw(indent+33) << "mediaControlGuaranteedDelivery = " << setprecision(indent) << m_mediaControlGuaranteedDelivery << '\n';
  if (HasOptionalField(e_silenceSuppression))
    strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  if (HasOptionalField(e_destination))
    strm << setw(indent+14) << "destination = " << setprecision(indent) << m_destination << '\n';
  if (HasOptionalField(e_dynamicRTPPayloadType))
    strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  if (HasOptionalField(e_mediaPacketization))
    strm << setw(indent+21) << "mediaPacketization = " << setprecision(indent) << m_mediaPacketization << '\n';
  if (HasOptionalField(e_transportCapability))
    strm << setw(indent+22) << "transportCapability = " << setprecision(indent) << m_transportCapability << '\n';
  if (HasOptionalField(e_redundancyEncoding))
    strm << setw(indent+21) << "redundancyEncoding = " << setprecision(indent) << m_redundancyEncoding << '\n';
  if (HasOptionalField(e_source))
    strm << setw(indent+9) << "source = " << setprecision(indent) << m_source << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  const H245_H2250LogicalChannelParameters & other = (const H245_H2250LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_associatedSessionID.Compare(other.m_associatedSessionID)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaGuaranteedDelivery.Compare(other.m_mediaGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlGuaranteedDelivery.Compare(other.m_mediaControlGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_destination.Compare(other.m_destination)) != EqualTo)
    return result;
  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;
  if ((result = m_mediaPacketization.Compare(other.m_mediaPacketization)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250LogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  length += m_sessionID.GetObjectLength();
  if (HasOptionalField(e_associatedSessionID))
    length += m_associatedSessionID.GetObjectLength();
  if (HasOptionalField(e_mediaChannel))
    length += m_mediaChannel.GetObjectLength();
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    length += m_mediaGuaranteedDelivery.GetObjectLength();
  if (HasOptionalField(e_mediaControlChannel))
    length += m_mediaControlChannel.GetObjectLength();
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    length += m_mediaControlGuaranteedDelivery.GetObjectLength();
  if (HasOptionalField(e_silenceSuppression))
    length += m_silenceSuppression.GetObjectLength();
  if (HasOptionalField(e_destination))
    length += m_destination.GetObjectLength();
  if (HasOptionalField(e_dynamicRTPPayloadType))
    length += m_dynamicRTPPayloadType.GetObjectLength();
  if (HasOptionalField(e_mediaPacketization))
    length += m_mediaPacketization.GetObjectLength();
  return length;
}


BOOL H245_H2250LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!m_sessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_associatedSessionID) && !m_associatedSessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaChannel) && !m_mediaChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaGuaranteedDelivery) && !m_mediaGuaranteedDelivery.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaControlChannel) && !m_mediaControlChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaControlGuaranteedDelivery) && !m_mediaControlGuaranteedDelivery.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_silenceSuppression) && !m_silenceSuppression.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destination) && !m_destination.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_dynamicRTPPayloadType) && !m_dynamicRTPPayloadType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mediaPacketization) && !m_mediaPacketization.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_transportCapability, m_transportCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_redundancyEncoding, m_redundancyEncoding))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_source, m_source))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_silenceSuppression))
    m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_destination))
    m_destination.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
  if (HasOptionalField(e_mediaPacketization))
    m_mediaPacketization.Encode(strm);
  KnownExtensionEncode(strm, e_transportCapability, m_transportCapability);
  KnownExtensionEncode(strm, e_redundancyEncoding, m_redundancyEncoding);
  KnownExtensionEncode(strm, e_source, m_source);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelParameters(*this);
}


//
// ModeElement
//

H245_ModeElement::H245_ModeElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H245_ModeElement::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  if (HasOptionalField(e_h223ModeParameters))
    strm << setw(indent+21) << "h223ModeParameters = " << setprecision(indent) << m_h223ModeParameters << '\n';
  if (HasOptionalField(e_v76ModeParameters))
    strm << setw(indent+20) << "v76ModeParameters = " << setprecision(indent) << m_v76ModeParameters << '\n';
  if (HasOptionalField(e_h2250ModeParameters))
    strm << setw(indent+22) << "h2250ModeParameters = " << setprecision(indent) << m_h2250ModeParameters << '\n';
  if (HasOptionalField(e_genericModeParameters))
    strm << setw(indent+24) << "genericModeParameters = " << setprecision(indent) << m_genericModeParameters << '\n';
  if (HasOptionalField(e_multiplexedStreamModeParameters))
    strm << setw(indent+34) << "multiplexedStreamModeParameters = " << setprecision(indent) << m_multiplexedStreamModeParameters << '\n';
  if (HasOptionalField(e_logicalChannelNumber))
    strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ModeElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ModeElement), PInvalidCast);
#endif
  const H245_ModeElement & other = (const H245_ModeElement &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_h223ModeParameters.Compare(other.m_h223ModeParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ModeElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  if (HasOptionalField(e_h223ModeParameters))
    length += m_h223ModeParameters.GetObjectLength();
  return length;
}


BOOL H245_ModeElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h223ModeParameters) && !m_h223ModeParameters.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_v76ModeParameters, m_v76ModeParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h2250ModeParameters, m_h2250ModeParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericModeParameters, m_genericModeParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multiplexedStreamModeParameters, m_multiplexedStreamModeParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_logicalChannelNumber, m_logicalChannelNumber))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ModeElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  if (HasOptionalField(e_h223ModeParameters))
    m_h223ModeParameters.Encode(strm);
  KnownExtensionEncode(strm, e_v76ModeParameters, m_v76ModeParameters);
  KnownExtensionEncode(strm, e_h2250ModeParameters, m_h2250ModeParameters);
  KnownExtensionEncode(strm, e_genericModeParameters, m_genericModeParameters);
  KnownExtensionEncode(strm, e_multiplexedStreamModeParameters, m_multiplexedStreamModeParameters);
  KnownExtensionEncode(strm, e_logicalChannelNumber, m_logicalChannelNumber);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ModeElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeElement::Class()), PInvalidCast);
#endif
  return new H245_ModeElement(*this);
}


//
// H263VideoMode
//

H245_H263VideoMode::H245_H263VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 3)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
  IncludeOptionalField(e_errorCompensation);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoMode::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resolution = " << setprecision(indent) << m_resolution << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  if (HasOptionalField(e_errorCompensation))
    strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_enhancementLayerInfo))
    strm << setw(indent+23) << "enhancementLayerInfo = " << setprecision(indent) << m_enhancementLayerInfo << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263VideoMode), PInvalidCast);
#endif
  const H245_H263VideoMode & other = (const H245_H263VideoMode &)obj;

  Comparison result;

  if ((result = m_resolution.Compare(other.m_resolution)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_resolution.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  length += m_unrestrictedVector.GetObjectLength();
  length += m_arithmeticCoding.GetObjectLength();
  length += m_advancedPrediction.GetObjectLength();
  length += m_pbFrames.GetObjectLength();
  return length;
}


BOOL H245_H263VideoMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_resolution.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;
  if (!m_unrestrictedVector.Decode(strm))
    return FALSE;
  if (!m_arithmeticCoding.Decode(strm))
    return FALSE;
  if (!m_advancedPrediction.Decode(strm))
    return FALSE;
  if (!m_pbFrames.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_errorCompensation, m_errorCompensation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h263Options, m_h263Options))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  KnownExtensionEncode(strm, e_errorCompensation, m_errorCompensation);
  KnownExtensionEncode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo);
  KnownExtensionEncode(strm, e_h263Options, m_h263Options);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H263VideoMode(*this);
}


//
// H263VideoCapability
//

H245_H263VideoCapability::H245_H263VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 8)
{
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 192400);
  m_hrd_B.SetConstraints(PASN_Object::FixedConstraint, 0, 524287);
  m_bppMaxKb.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_slowSqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowQcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  IncludeOptionalField(e_errorCompensation);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoCapability::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  if (HasOptionalField(e_hrd_B))
    strm << setw(indent+8) << "hrd_B = " << setprecision(indent) << m_hrd_B << '\n';
  if (HasOptionalField(e_bppMaxKb))
    strm << setw(indent+11) << "bppMaxKb = " << setprecision(indent) << m_bppMaxKb << '\n';
  if (HasOptionalField(e_slowSqcifMPI))
    strm << setw(indent+15) << "slowSqcifMPI = " << setprecision(indent) << m_slowSqcifMPI << '\n';
  if (HasOptionalField(e_slowQcifMPI))
    strm << setw(indent+14) << "slowQcifMPI = " << setprecision(indent) << m_slowQcifMPI << '\n';
  if (HasOptionalField(e_slowCifMPI))
    strm << setw(indent+13) << "slowCifMPI = " << setprecision(indent) << m_slowCifMPI << '\n';
  if (HasOptionalField(e_slowCif4MPI))
    strm << setw(indent+14) << "slowCif4MPI = " << setprecision(indent) << m_slowCif4MPI << '\n';
  if (HasOptionalField(e_slowCif16MPI))
    strm << setw(indent+15) << "slowCif16MPI = " << setprecision(indent) << m_slowCif16MPI << '\n';
  if (HasOptionalField(e_errorCompensation))
    strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_enhancementLayerInfo))
    strm << setw(indent+23) << "enhancementLayerInfo = " << setprecision(indent) << m_enhancementLayerInfo << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263VideoCapability), PInvalidCast);
#endif
  const H245_H263VideoCapability & other = (const H245_H263VideoCapability &)obj;

  Comparison result;

  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_hrd_B.Compare(other.m_hrd_B)) != EqualTo)
    return result;
  if ((result = m_bppMaxKb.Compare(other.m_bppMaxKb)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_sqcifMPI))
    length += m_sqcifMPI.GetObjectLength();
  if (HasOptionalField(e_qcifMPI))
    length += m_qcifMPI.GetObjectLength();
  if (HasOptionalField(e_cifMPI))
    length += m_cifMPI.GetObjectLength();
  if (HasOptionalField(e_cif4MPI))
    length += m_cif4MPI.GetObjectLength();
  if (HasOptionalField(e_cif16MPI))
    length += m_cif16MPI.GetObjectLength();
  length += m_maxBitRate.GetObjectLength();
  length += m_unrestrictedVector.GetObjectLength();
  length += m_arithmeticCoding.GetObjectLength();
  length += m_advancedPrediction.GetObjectLength();
  length += m_pbFrames.GetObjectLength();
  length += m_temporalSpatialTradeOffCapability.GetObjectLength();
  if (HasOptionalField(e_hrd_B))
    length += m_hrd_B.GetObjectLength();
  if (HasOptionalField(e_bppMaxKb))
    length += m_bppMaxKb.GetObjectLength();
  return length;
}


BOOL H245_H263VideoCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_sqcifMPI) && !m_sqcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qcifMPI) && !m_qcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cifMPI) && !m_cifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif4MPI) && !m_cif4MPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif16MPI) && !m_cif16MPI.Decode(strm))
    return FALSE;
  if (!m_maxBitRate.Decode(strm))
    return FALSE;
  if (!m_unrestrictedVector.Decode(strm))
    return FALSE;
  if (!m_arithmeticCoding.Decode(strm))
    return FALSE;
  if (!m_advancedPrediction.Decode(strm))
    return FALSE;
  if (!m_pbFrames.Decode(strm))
    return FALSE;
  if (!m_temporalSpatialTradeOffCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_hrd_B) && !m_hrd_B.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_bppMaxKb) && !m_bppMaxKb.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_slowSqcifMPI, m_slowSqcifMPI))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_slowQcifMPI, m_slowQcifMPI))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_slowCifMPI, m_slowCifMPI))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_slowCif4MPI, m_slowCif4MPI))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_slowCif16MPI, m_slowCif16MPI))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_errorCompensation, m_errorCompensation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h263Options, m_h263Options))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_hrd_B))
    m_hrd_B.Encode(strm);
  if (HasOptionalField(e_bppMaxKb))
    m_bppMaxKb.Encode(strm);
  KnownExtensionEncode(strm, e_slowSqcifMPI, m_slowSqcifMPI);
  KnownExtensionEncode(strm, e_slowQcifMPI, m_slowQcifMPI);
  KnownExtensionEncode(strm, e_slowCifMPI, m_slowCifMPI);
  KnownExtensionEncode(strm, e_slowCif4MPI, m_slowCif4MPI);
  KnownExtensionEncode(strm, e_slowCif16MPI, m_slowCif16MPI);
  KnownExtensionEncode(strm, e_errorCompensation, m_errorCompensation);
  KnownExtensionEncode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo);
  KnownExtensionEncode(strm, e_h263Options, m_h263Options);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H263VideoCapability(*this);
}


//
// EnhancementOptions
//

H245_EnhancementOptions::H245_EnhancementOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 11, TRUE, 0)
{
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 192400);
  m_slowSqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowQcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
}


#ifndef PASN_NOPRINTON
void H245_EnhancementOptions::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  if (HasOptionalField(e_slowSqcifMPI))
    strm << setw(indent+15) << "slowSqcifMPI = " << setprecision(indent) << m_slowSqcifMPI << '\n';
  if (HasOptionalField(e_slowQcifMPI))
    strm << setw(indent+14) << "slowQcifMPI = " << setprecision(indent) << m_slowQcifMPI << '\n';
  if (HasOptionalField(e_slowCifMPI))
    strm << setw(indent+13) << "slowCifMPI = " << setprecision(indent) << m_slowCifMPI << '\n';
  if (HasOptionalField(e_slowCif4MPI))
    strm << setw(indent+14) << "slowCif4MPI = " << setprecision(indent) << m_slowCif4MPI << '\n';
  if (HasOptionalField(e_slowCif16MPI))
    strm << setw(indent+15) << "slowCif16MPI = " << setprecision(indent) << m_slowCif16MPI << '\n';
  strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EnhancementOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EnhancementOptions), PInvalidCast);
#endif
  const H245_EnhancementOptions & other = (const H245_EnhancementOptions &)obj;

  Comparison result;

  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_slowSqcifMPI.Compare(other.m_slowSqcifMPI)) != EqualTo)
    return result;
  if ((result = m_slowQcifMPI.Compare(other.m_slowQcifMPI)) != EqualTo)
    return result;
  if ((result = m_slowCifMPI.Compare(other.m_slowCifMPI)) != EqualTo)
    return result;
  if ((result = m_slowCif4MPI.Compare(other.m_slowCif4MPI)) != EqualTo)
    return result;
  if ((result = m_slowCif16MPI.Compare(other.m_slowCif16MPI)) != EqualTo)
    return result;
  if ((result = m_errorCompensation.Compare(other.m_errorCompensation)) != EqualTo)
    return result;
  if ((result = m_h263Options.Compare(other.m_h263Options)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EnhancementOptions::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_sqcifMPI))
    length += m_sqcifMPI.GetObjectLength();
  if (HasOptionalField(e_qcifMPI))
    length += m_qcifMPI.GetObjectLength();
  if (HasOptionalField(e_cifMPI))
    length += m_cifMPI.GetObjectLength();
  if (HasOptionalField(e_cif4MPI))
    length += m_cif4MPI.GetObjectLength();
  if (HasOptionalField(e_cif16MPI))
    length += m_cif16MPI.GetObjectLength();
  length += m_maxBitRate.GetObjectLength();
  length += m_unrestrictedVector.GetObjectLength();
  length += m_arithmeticCoding.GetObjectLength();
  length += m_temporalSpatialTradeOffCapability.GetObjectLength();
  if (HasOptionalField(e_slowSqcifMPI))
    length += m_slowSqcifMPI.GetObjectLength();
  if (HasOptionalField(e_slowQcifMPI))
    length += m_slowQcifMPI.GetObjectLength();
  if (HasOptionalField(e_slowCifMPI))
    length += m_slowCifMPI.GetObjectLength();
  if (HasOptionalField(e_slowCif4MPI))
    length += m_slowCif4MPI.GetObjectLength();
  if (HasOptionalField(e_slowCif16MPI))
    length += m_slowCif16MPI.GetObjectLength();
  length += m_errorCompensation.GetObjectLength();
  if (HasOptionalField(e_h263Options))
    length += m_h263Options.GetObjectLength();
  return length;
}


BOOL H245_EnhancementOptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_sqcifMPI) && !m_sqcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qcifMPI) && !m_qcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cifMPI) && !m_cifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif4MPI) && !m_cif4MPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif16MPI) && !m_cif16MPI.Decode(strm))
    return FALSE;
  if (!m_maxBitRate.Decode(strm))
    return FALSE;
  if (!m_unrestrictedVector.Decode(strm))
    return FALSE;
  if (!m_arithmeticCoding.Decode(strm))
    return FALSE;
  if (!m_temporalSpatialTradeOffCapability.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_slowSqcifMPI) && !m_slowSqcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_slowQcifMPI) && !m_slowQcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_slowCifMPI) && !m_slowCifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_slowCif4MPI) && !m_slowCif4MPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_slowCif16MPI) && !m_slowCif16MPI.Decode(strm))
    return FALSE;
  if (!m_errorCompensation.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h263Options) && !m_h263Options.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EnhancementOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_slowSqcifMPI))
    m_slowSqcifMPI.Encode(strm);
  if (HasOptionalField(e_slowQcifMPI))
    m_slowQcifMPI.Encode(strm);
  if (HasOptionalField(e_slowCifMPI))
    m_slowCifMPI.Encode(strm);
  if (HasOptionalField(e_slowCif4MPI))
    m_slowCif4MPI.Encode(strm);
  if (HasOptionalField(e_slowCif16MPI))
    m_slowCif16MPI.Encode(strm);
  m_errorCompensation.Encode(strm);
  if (HasOptionalField(e_h263Options))
    m_h263Options.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EnhancementOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EnhancementOptions::Class()), PInvalidCast);
#endif
  return new H245_EnhancementOptions(*this);
}


//
// BEnhancementParameters
//

H245_BEnhancementParameters::H245_BEnhancementParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfBPictures.SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


#ifndef PASN_NOPRINTON
void H245_BEnhancementParameters::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "enhancementOptions = " << setprecision(indent) << m_enhancementOptions << '\n';
  strm << setw(indent+20) << "numberOfBPictures = " << setprecision(indent) << m_numberOfBPictures << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_BEnhancementParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_BEnhancementParameters), PInvalidCast);
#endif
  const H245_BEnhancementParameters & other = (const H245_BEnhancementParameters &)obj;

  Comparison result;

  if ((result = m_enhancementOptions.Compare(other.m_enhancementOptions)) != EqualTo)
    return result;
  if ((result = m_numberOfBPictures.Compare(other.m_numberOfBPictures)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_BEnhancementParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_enhancementOptions.GetObjectLength();
  length += m_numberOfBPictures.GetObjectLength();
  return length;
}


BOOL H245_BEnhancementParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_enhancementOptions.Decode(strm))
    return FALSE;
  if (!m_numberOfBPictures.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_BEnhancementParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_enhancementOptions.Encode(strm);
  m_numberOfBPictures.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_BEnhancementParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_BEnhancementParameters::Class()), PInvalidCast);
#endif
  return new H245_BEnhancementParameters(*this);
}


#endif // if ! H323_DISABLE_H245


// End of h245_3.cxx
