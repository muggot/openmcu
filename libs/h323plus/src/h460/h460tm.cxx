//
// H460tm.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h460tm.h"
#endif

#include <ptlib.h>
#include "h460/h460tm.h"

#define new PNEW


#if ! H323_DISABLE_H460TM

#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460TM_TMmode[]={
        {"tmOpen",1}
       ,{"tmPublic",2}
       ,{"tmPrivate",3}
       ,{"tmBroadcast",4}
       ,{"tmReceive",5}
};
#endif
//
// TMmode
//

H460TM_TMmode::H460TM_TMmode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 5, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460TM_TMmode,5
#endif
    )
{
}


H460TM_TMmode & H460TM_TMmode::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H460TM_TMmode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460TM_TMmode::Class()), PInvalidCast);
#endif
  return new H460TM_TMmode(*this);
}


//
// MultipointTM
//

H460TM_MultipointTM::H460TM_MultipointTM(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_message.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_sender.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_receiver.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H460TM_MultipointTM::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "message = " << setprecision(indent) << m_message << '\n';
  if (HasOptionalField(e_sender))
    strm << setw(indent+9) << "sender = " << setprecision(indent) << m_sender << '\n';
  if (HasOptionalField(e_receiver))
    strm << setw(indent+11) << "receiver = " << setprecision(indent) << m_receiver << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460TM_MultipointTM::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460TM_MultipointTM), PInvalidCast);
#endif
  const H460TM_MultipointTM & other = (const H460TM_MultipointTM &)obj;

  Comparison result;

  if ((result = m_message.Compare(other.m_message)) != EqualTo)
    return result;
  if ((result = m_sender.Compare(other.m_sender)) != EqualTo)
    return result;
  if ((result = m_receiver.Compare(other.m_receiver)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460TM_MultipointTM::GetDataLength() const
{
  PINDEX length = 0;
  length += m_message.GetObjectLength();
  if (HasOptionalField(e_sender))
    length += m_sender.GetObjectLength();
  if (HasOptionalField(e_receiver))
    length += m_receiver.GetObjectLength();
  return length;
}


BOOL H460TM_MultipointTM::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_message.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sender) && !m_sender.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_receiver) && !m_receiver.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460TM_MultipointTM::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_message.Encode(strm);
  if (HasOptionalField(e_sender))
    m_sender.Encode(strm);
  if (HasOptionalField(e_receiver))
    m_receiver.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460TM_MultipointTM::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460TM_MultipointTM::Class()), PInvalidCast);
#endif
  return new H460TM_MultipointTM(*this);
}


#endif // if ! H323_DISABLE_H460TM


// End of H460tm.cxx
