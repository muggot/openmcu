//
// H460pres.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h460pres.h"
#endif

#include <ptlib.h>
#include "h460/h460pres.h"

#define new PNEW


#if ! H323_DISABLE_H460P




#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceMessage[]={
      {"presenceStatus",0}
     ,{"presenceInstruct",1}
     ,{"presenceAuthorize",2}
     ,{"presenceNotify",3}
     ,{"presenceRequest",4}
     ,{"presenceResponse",5}
     ,{"presenceAlive",6}
     ,{"presenceRemove",7}
     ,{"presenceAlert",8}
};
#endif
//
// PresenceMessage
//

H460P_PresenceMessage::H460P_PresenceMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 9, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceMessage,9
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceStatus &() const
#else
H460P_PresenceMessage::operator H460P_PresenceStatus &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceStatus), PInvalidCast);
#endif
  return *(H460P_PresenceStatus *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceStatus &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceStatus), PInvalidCast);
#endif
  return *(H460P_PresenceStatus *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceInstruct &() const
#else
H460P_PresenceMessage::operator H460P_PresenceInstruct &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceInstruct), PInvalidCast);
#endif
  return *(H460P_PresenceInstruct *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceInstruct &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceInstruct), PInvalidCast);
#endif
  return *(H460P_PresenceInstruct *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceAuthorize &() const
#else
H460P_PresenceMessage::operator H460P_PresenceAuthorize &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAuthorize), PInvalidCast);
#endif
  return *(H460P_PresenceAuthorize *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceAuthorize &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAuthorize), PInvalidCast);
#endif
  return *(H460P_PresenceAuthorize *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceNotify &() const
#else
H460P_PresenceMessage::operator H460P_PresenceNotify &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceNotify), PInvalidCast);
#endif
  return *(H460P_PresenceNotify *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceNotify &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceNotify), PInvalidCast);
#endif
  return *(H460P_PresenceNotify *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceRequest &() const
#else
H460P_PresenceMessage::operator H460P_PresenceRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceRequest), PInvalidCast);
#endif
  return *(H460P_PresenceRequest *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceRequest), PInvalidCast);
#endif
  return *(H460P_PresenceRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceResponse &() const
#else
H460P_PresenceMessage::operator H460P_PresenceResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceResponse), PInvalidCast);
#endif
  return *(H460P_PresenceResponse *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceResponse), PInvalidCast);
#endif
  return *(H460P_PresenceResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceAlive &() const
#else
H460P_PresenceMessage::operator H460P_PresenceAlive &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAlive), PInvalidCast);
#endif
  return *(H460P_PresenceAlive *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceAlive &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAlive), PInvalidCast);
#endif
  return *(H460P_PresenceAlive *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceRemove &() const
#else
H460P_PresenceMessage::operator H460P_PresenceRemove &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceRemove), PInvalidCast);
#endif
  return *(H460P_PresenceRemove *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceRemove &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceRemove), PInvalidCast);
#endif
  return *(H460P_PresenceRemove *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceMessage::operator H460P_PresenceAlert &() const
#else
H460P_PresenceMessage::operator H460P_PresenceAlert &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAlert), PInvalidCast);
#endif
  return *(H460P_PresenceAlert *)choice;
}


H460P_PresenceMessage::operator const H460P_PresenceAlert &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H460P_PresenceAlert), PInvalidCast);
#endif
  return *(H460P_PresenceAlert *)choice;
}


BOOL H460P_PresenceMessage::CreateObject()
{
  switch (tag) {
    case e_presenceStatus :
      choice = new H460P_PresenceStatus();
      return TRUE;
    case e_presenceInstruct :
      choice = new H460P_PresenceInstruct();
      return TRUE;
    case e_presenceAuthorize :
      choice = new H460P_PresenceAuthorize();
      return TRUE;
    case e_presenceNotify :
      choice = new H460P_PresenceNotify();
      return TRUE;
    case e_presenceRequest :
      choice = new H460P_PresenceRequest();
      return TRUE;
    case e_presenceResponse :
      choice = new H460P_PresenceResponse();
      return TRUE;
    case e_presenceAlive :
      choice = new H460P_PresenceAlive();
      return TRUE;
    case e_presenceRemove :
      choice = new H460P_PresenceRemove();
      return TRUE;
    case e_presenceAlert :
      choice = new H460P_PresenceAlert();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H460P_PresenceMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceMessage::Class()), PInvalidCast);
#endif
  return new H460P_PresenceMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceInstruction[]={
      {"subscribe",0}
     ,{"unsubscribe",1}
     ,{"block",2}
     ,{"unblock",3}
};
#endif
//
// PresenceInstruction
//

H460P_PresenceInstruction::H460P_PresenceInstruction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceInstruction,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceInstruction::operator H225_AliasAddress &() const
#else
H460P_PresenceInstruction::operator H225_AliasAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


H460P_PresenceInstruction::operator const H225_AliasAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


BOOL H460P_PresenceInstruction::CreateObject()
{
  switch (tag) {
    case e_subscribe :
    case e_unsubscribe :
    case e_block :
    case e_unblock :
      choice = new H225_AliasAddress();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H460P_PresenceInstruction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceInstruction::Class()), PInvalidCast);
#endif
  return new H460P_PresenceInstruction(*this);
}


//
// PresenceIdentifier
//

H460P_PresenceIdentifier::H460P_PresenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_guid.SetConstraints(PASN_Object::FixedConstraint, 16);
}


#ifndef PASN_NOPRINTON
void H460P_PresenceIdentifier::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "guid = " << setprecision(indent) << m_guid << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceIdentifier), PInvalidCast);
#endif
  const H460P_PresenceIdentifier & other = (const H460P_PresenceIdentifier &)obj;

  Comparison result;

  if ((result = m_guid.Compare(other.m_guid)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceIdentifier::GetDataLength() const
{
  PINDEX length = 0;
  length += m_guid.GetObjectLength();
  return length;
}


BOOL H460P_PresenceIdentifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_guid.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_guid.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceIdentifier::Class()), PInvalidCast);
#endif
  return new H460P_PresenceIdentifier(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceState[]={
      {"hidden",0}
     ,{"available",1}
     ,{"online",2}
     ,{"offline",3}
     ,{"onCall",4}
     ,{"voiceMail",5}
     ,{"notAvailable",6}
     ,{"generic",7}
};
#endif
//
// PresenceState
//

H460P_PresenceState::H460P_PresenceState(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceState,8
#endif
)
{
}


BOOL H460P_PresenceState::CreateObject()
{
  switch (tag) {
    case e_hidden :
    case e_available :
    case e_online :
    case e_offline :
    case e_onCall :
    case e_voiceMail :
    case e_notAvailable :
      choice = new PASN_Null();
      return TRUE;
    case e_generic :
      choice = new PASN_BMPString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H460P_PresenceState::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceState::Class()), PInvalidCast);
#endif
  return new H460P_PresenceState(*this);
}


//
// ArrayOf_PresenceNotification
//

H460P_ArrayOf_PresenceNotification::H460P_ArrayOf_PresenceNotification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceNotification::CreateObject() const
{
  return new H460P_PresenceNotification;
}


H460P_PresenceNotification & H460P_ArrayOf_PresenceNotification::operator[](PINDEX i) const
{
  return (H460P_PresenceNotification &)array[i];
}


PObject * H460P_ArrayOf_PresenceNotification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceNotification::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceNotification(*this);
}


//
// ArrayOf_PresenceInstruction
//

H460P_ArrayOf_PresenceInstruction::H460P_ArrayOf_PresenceInstruction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceInstruction::CreateObject() const
{
  return new H460P_PresenceInstruction;
}


H460P_PresenceInstruction & H460P_ArrayOf_PresenceInstruction::operator[](PINDEX i) const
{
  return (H460P_PresenceInstruction &)array[i];
}


PObject * H460P_ArrayOf_PresenceInstruction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceInstruction::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceInstruction(*this);
}


//
// ArrayOf_PresenceSubscription
//

H460P_ArrayOf_PresenceSubscription::H460P_ArrayOf_PresenceSubscription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceSubscription::CreateObject() const
{
  return new H460P_PresenceSubscription;
}


H460P_PresenceSubscription & H460P_ArrayOf_PresenceSubscription::operator[](PINDEX i) const
{
  return (H460P_PresenceSubscription &)array[i];
}


PObject * H460P_ArrayOf_PresenceSubscription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceSubscription::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceSubscription(*this);
}


//
// ArrayOf_ClearToken
//

H460P_ArrayOf_ClearToken::H460P_ArrayOf_ClearToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_ClearToken::CreateObject() const
{
  return new H235_ClearToken;
}


H235_ClearToken & H460P_ArrayOf_ClearToken::operator[](PINDEX i) const
{
  return (H235_ClearToken &)array[i];
}


PObject * H460P_ArrayOf_ClearToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_ClearToken::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_ClearToken(*this);
}


//
// ArrayOf_CryptoH323Token
//

H460P_ArrayOf_CryptoH323Token::H460P_ArrayOf_CryptoH323Token(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_CryptoH323Token::CreateObject() const
{
  return new H225_CryptoH323Token;
}


H225_CryptoH323Token & H460P_ArrayOf_CryptoH323Token::operator[](PINDEX i) const
{
  return (H225_CryptoH323Token &)array[i];
}


PObject * H460P_ArrayOf_CryptoH323Token::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_CryptoH323Token::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_CryptoH323Token(*this);
}


//
// ArrayOf_PresenceIdentifier
//

H460P_ArrayOf_PresenceIdentifier::H460P_ArrayOf_PresenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceIdentifier::CreateObject() const
{
  return new H460P_PresenceIdentifier;
}


H460P_PresenceIdentifier & H460P_ArrayOf_PresenceIdentifier::operator[](PINDEX i) const
{
  return (H460P_PresenceIdentifier &)array[i];
}


PObject * H460P_ArrayOf_PresenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceIdentifier::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceIdentifier(*this);
}


//
// ArrayOf_AliasAddress
//

H460P_ArrayOf_AliasAddress::H460P_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H460P_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H460P_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_AliasAddress(*this);
}


//
// ArrayOf_GenericData
//

H460P_ArrayOf_GenericData::H460P_ArrayOf_GenericData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_GenericData::CreateObject() const
{
  return new H225_GenericData;
}


H225_GenericData & H460P_ArrayOf_GenericData::operator[](PINDEX i) const
{
  return (H225_GenericData &)array[i];
}


PObject * H460P_ArrayOf_GenericData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_GenericData::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_GenericData(*this);
}


//
// PresenceStatus
//

H460P_PresenceStatus::H460P_PresenceStatus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceStatus::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "notification = " << setprecision(indent) << m_notification << '\n';
  if (HasOptionalField(e_instruction))
    strm << setw(indent+14) << "instruction = " << setprecision(indent) << m_instruction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceStatus::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceStatus), PInvalidCast);
#endif
  const H460P_PresenceStatus & other = (const H460P_PresenceStatus &)obj;

  Comparison result;

  if ((result = m_notification.Compare(other.m_notification)) != EqualTo)
    return result;
  if ((result = m_instruction.Compare(other.m_instruction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceStatus::GetDataLength() const
{
  PINDEX length = 0;
  length += m_notification.GetObjectLength();
  if (HasOptionalField(e_instruction))
    length += m_instruction.GetObjectLength();
  return length;
}


BOOL H460P_PresenceStatus::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_notification.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_instruction) && !m_instruction.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceStatus::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_notification.Encode(strm);
  if (HasOptionalField(e_instruction))
    m_instruction.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceStatus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceStatus::Class()), PInvalidCast);
#endif
  return new H460P_PresenceStatus(*this);
}


//
// PresenceInstruct
//

H460P_PresenceInstruct::H460P_PresenceInstruct(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceInstruct::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "instruction = " << setprecision(indent) << m_instruction << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceInstruct::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceInstruct), PInvalidCast);
#endif
  const H460P_PresenceInstruct & other = (const H460P_PresenceInstruct &)obj;

  Comparison result;

  if ((result = m_instruction.Compare(other.m_instruction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceInstruct::GetDataLength() const
{
  PINDEX length = 0;
  length += m_instruction.GetObjectLength();
  return length;
}


BOOL H460P_PresenceInstruct::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_instruction.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceInstruct::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_instruction.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceInstruct::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceInstruct::Class()), PInvalidCast);
#endif
  return new H460P_PresenceInstruct(*this);
}


//
// PresenceAuthorize
//

H460P_PresenceAuthorize::H460P_PresenceAuthorize(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceAuthorize::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "subscription = " << setprecision(indent) << m_subscription << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceAuthorize::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceAuthorize), PInvalidCast);
#endif
  const H460P_PresenceAuthorize & other = (const H460P_PresenceAuthorize &)obj;

  Comparison result;

  if ((result = m_subscription.Compare(other.m_subscription)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceAuthorize::GetDataLength() const
{
  PINDEX length = 0;
  length += m_subscription.GetObjectLength();
  return length;
}


BOOL H460P_PresenceAuthorize::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_subscription.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceAuthorize::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_subscription.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceAuthorize::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceAuthorize::Class()), PInvalidCast);
#endif
  return new H460P_PresenceAuthorize(*this);
}


//
// PresenceNotify
//

H460P_PresenceNotify::H460P_PresenceNotify(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceNotify::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "notification = " << setprecision(indent) << m_notification << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceNotify::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceNotify), PInvalidCast);
#endif
  const H460P_PresenceNotify & other = (const H460P_PresenceNotify &)obj;

  Comparison result;

  if ((result = m_notification.Compare(other.m_notification)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceNotify::GetDataLength() const
{
  PINDEX length = 0;
  length += m_notification.GetObjectLength();
  return length;
}


BOOL H460P_PresenceNotify::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_notification.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceNotify::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_notification.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceNotify::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceNotify::Class()), PInvalidCast);
#endif
  return new H460P_PresenceNotify(*this);
}


//
// PresenceRequest
//

H460P_PresenceRequest::H460P_PresenceRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceRequest::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "subscription = " << setprecision(indent) << m_subscription << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceRequest), PInvalidCast);
#endif
  const H460P_PresenceRequest & other = (const H460P_PresenceRequest &)obj;

  Comparison result;

  if ((result = m_subscription.Compare(other.m_subscription)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_subscription.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H460P_PresenceRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_subscription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_subscription.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceRequest::Class()), PInvalidCast);
#endif
  return new H460P_PresenceRequest(*this);
}


//
// PresenceResponse
//

H460P_PresenceResponse::H460P_PresenceResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceResponse::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "subscription = " << setprecision(indent) << m_subscription << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceResponse), PInvalidCast);
#endif
  const H460P_PresenceResponse & other = (const H460P_PresenceResponse &)obj;

  Comparison result;

  if ((result = m_subscription.Compare(other.m_subscription)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_subscription.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H460P_PresenceResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_subscription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_subscription.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceResponse::Class()), PInvalidCast);
#endif
  return new H460P_PresenceResponse(*this);
}


//
// PresenceAlive
//

H460P_PresenceAlive::H460P_PresenceAlive(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceAlive::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "identifier = " << setprecision(indent) << m_identifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceAlive::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceAlive), PInvalidCast);
#endif
  const H460P_PresenceAlive & other = (const H460P_PresenceAlive &)obj;

  Comparison result;

  if ((result = m_identifier.Compare(other.m_identifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceAlive::GetDataLength() const
{
  PINDEX length = 0;
  length += m_identifier.GetObjectLength();
  return length;
}


BOOL H460P_PresenceAlive::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_identifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceAlive::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_identifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceAlive::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceAlive::Class()), PInvalidCast);
#endif
  return new H460P_PresenceAlive(*this);
}


//
// PresenceRemove
//

H460P_PresenceRemove::H460P_PresenceRemove(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceRemove::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "identifier = " << setprecision(indent) << m_identifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceRemove::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceRemove), PInvalidCast);
#endif
  const H460P_PresenceRemove & other = (const H460P_PresenceRemove &)obj;

  Comparison result;

  if ((result = m_identifier.Compare(other.m_identifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceRemove::GetDataLength() const
{
  PINDEX length = 0;
  length += m_identifier.GetObjectLength();
  return length;
}


BOOL H460P_PresenceRemove::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_identifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceRemove::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_identifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceRemove::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceRemove::Class()), PInvalidCast);
#endif
  return new H460P_PresenceRemove(*this);
}


//
// PresenceAlert
//

H460P_PresenceAlert::H460P_PresenceAlert(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceAlert::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "notification = " << setprecision(indent) << m_notification << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceAlert::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceAlert), PInvalidCast);
#endif
  const H460P_PresenceAlert & other = (const H460P_PresenceAlert &)obj;

  Comparison result;

  if ((result = m_notification.Compare(other.m_notification)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceAlert::GetDataLength() const
{
  PINDEX length = 0;
  length += m_notification.GetObjectLength();
  return length;
}


BOOL H460P_PresenceAlert::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_notification.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceAlert::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_notification.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceAlert::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceAlert::Class()), PInvalidCast);
#endif
  return new H460P_PresenceAlert(*this);
}


//
// PresenceSubscription
//

H460P_PresenceSubscription::H460P_PresenceSubscription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceSubscription::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "subscribe = " << setprecision(indent) << m_subscribe << '\n';
  strm << setw(indent+10) << "aliases = " << setprecision(indent) << m_aliases << '\n';
  if (HasOptionalField(e_approved))
    strm << setw(indent+11) << "approved = " << setprecision(indent) << m_approved << '\n';
  if (HasOptionalField(e_rasAddress))
    strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_identifier))
    strm << setw(indent+13) << "identifier = " << setprecision(indent) << m_identifier << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceSubscription::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceSubscription), PInvalidCast);
#endif
  const H460P_PresenceSubscription & other = (const H460P_PresenceSubscription &)obj;

  Comparison result;

  if ((result = m_subscribe.Compare(other.m_subscribe)) != EqualTo)
    return result;
  if ((result = m_aliases.Compare(other.m_aliases)) != EqualTo)
    return result;
  if ((result = m_approved.Compare(other.m_approved)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;
  if ((result = m_identifier.Compare(other.m_identifier)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceSubscription::GetDataLength() const
{
  PINDEX length = 0;
  length += m_subscribe.GetObjectLength();
  length += m_aliases.GetObjectLength();
  if (HasOptionalField(e_approved))
    length += m_approved.GetObjectLength();
  if (HasOptionalField(e_rasAddress))
    length += m_rasAddress.GetObjectLength();
  if (HasOptionalField(e_timeToLive))
    length += m_timeToLive.GetObjectLength();
  if (HasOptionalField(e_identifier))
    length += m_identifier.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H460P_PresenceSubscription::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_subscribe.Decode(strm))
    return FALSE;
  if (!m_aliases.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_approved) && !m_approved.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rasAddress) && !m_rasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeToLive) && !m_timeToLive.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_identifier) && !m_identifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceSubscription::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_subscribe.Encode(strm);
  m_aliases.Encode(strm);
  if (HasOptionalField(e_approved))
    m_approved.Encode(strm);
  if (HasOptionalField(e_rasAddress))
    m_rasAddress.Encode(strm);
  if (HasOptionalField(e_timeToLive))
    m_timeToLive.Encode(strm);
  if (HasOptionalField(e_identifier))
    m_identifier.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceSubscription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceSubscription::Class()), PInvalidCast);
#endif
  return new H460P_PresenceSubscription(*this);
}


//
// Presentity
//

H460P_Presentity::H460P_Presentity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_display.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H460P_Presentity::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "state = " << setprecision(indent) << m_state << '\n';
  if (HasOptionalField(e_display))
    strm << setw(indent+10) << "display = " << setprecision(indent) << m_display << '\n';
  if (HasOptionalField(e_geolocation))
    strm << setw(indent+14) << "geolocation = " << setprecision(indent) << m_geolocation << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_Presentity::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_Presentity), PInvalidCast);
#endif
  const H460P_Presentity & other = (const H460P_Presentity &)obj;

  Comparison result;

  if ((result = m_state.Compare(other.m_state)) != EqualTo)
    return result;
  if ((result = m_display.Compare(other.m_display)) != EqualTo)
    return result;
  if ((result = m_geolocation.Compare(other.m_geolocation)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_Presentity::GetDataLength() const
{
  PINDEX length = 0;
  length += m_state.GetObjectLength();
  if (HasOptionalField(e_display))
    length += m_display.GetObjectLength();
  if (HasOptionalField(e_geolocation))
    length += m_geolocation.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H460P_Presentity::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_state.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_display) && !m_display.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_geolocation) && !m_geolocation.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_Presentity::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_state.Encode(strm);
  if (HasOptionalField(e_display))
    m_display.Encode(strm);
  if (HasOptionalField(e_geolocation))
    m_geolocation.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_Presentity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_Presentity::Class()), PInvalidCast);
#endif
  return new H460P_Presentity(*this);
}


//
// PresenceNotification
//

H460P_PresenceNotification::H460P_PresenceNotification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceNotification::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "presentity = " << setprecision(indent) << m_presentity << '\n';
  if (HasOptionalField(e_aliasAddress))
    strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  if (HasOptionalField(e_subscribers))
    strm << setw(indent+14) << "subscribers = " << setprecision(indent) << m_subscribers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceNotification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceNotification), PInvalidCast);
#endif
  const H460P_PresenceNotification & other = (const H460P_PresenceNotification &)obj;

  Comparison result;

  if ((result = m_presentity.Compare(other.m_presentity)) != EqualTo)
    return result;
  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;
  if ((result = m_subscribers.Compare(other.m_subscribers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceNotification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_presentity.GetObjectLength();
  if (HasOptionalField(e_aliasAddress))
    length += m_aliasAddress.GetObjectLength();
  if (HasOptionalField(e_subscribers))
    length += m_subscribers.GetObjectLength();
  return length;
}


BOOL H460P_PresenceNotification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_presentity.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_aliasAddress) && !m_aliasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subscribers) && !m_subscribers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceNotification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_presentity.Encode(strm);
  if (HasOptionalField(e_aliasAddress))
    m_aliasAddress.Encode(strm);
  if (HasOptionalField(e_subscribers))
    m_subscribers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceNotification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceNotification::Class()), PInvalidCast);
#endif
  return new H460P_PresenceNotification(*this);
}


#endif // if ! H323_DISABLE_H460P


// End of H460pres.cxx
